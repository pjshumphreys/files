<!DOCTYPE HTML>
<html lang="en">
  <head>
    <title>three.js webgl - dynamic procedural terrain</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style type="text/css">
      body {
        background: #000;
        color: #999;
        padding: 0;
        margin: 0;
        overflow: hidden;
        font-family: georgia;
        font-size:1em;
        text-align: center;
      }

      #info {
        position: absolute;
        top: 10px;
        width: 100%;
      }

      #goFS {
        position:absolute;
        z-index: 1;
        top: 0;
        left: 0;
        width:100%;
        height:100%;
        opacity:0;
      }

      a {
        color: #fb0;
      }

      #footer {
        position: absolute;
        bottom: 10px;
        width: 100%;
      }

      .h {
        color: #fb0;
      }

      .c {
        display: inline;
        margin-left: 1em;
      }

         #left_hud {
        pointer-events: none;
        position: absolute;
        z-index: 3;
        left: 0;
        width: 45%;
        height: 100%;
        margin-left: 2.5%;
    }
    #right_hud {
        pointer-events: none;
        position: absolute;
        z-index: 3;
        right: 0;
        width: 45%;
        height: 100%;
        margin-right: 2.5%;
    }


    #guide_circle_left {
        pointer-events: none;
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%,-50%);
        width: 2.5vw;
        height: 2.5vw;
        border-radius: 100%;
    }

    .other-ball {
      width: 1px;
      height: 1px;
      border-radius: 50%;
      background: #fff;
      position: absolute;
      z-index: 2;
      transform: translate(-50%, -50%);
      top:50%;
      left:50%;
    }

    #guide_circle_right {
        pointer-events: none;
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%,-50%);
        width: 2.5vw;
        height: 2.5vw;
        border-radius: 100%;
    }
    </style>
  </head>

  <body>
    <div id="left_hud">
        <div id="guide_circle_left"><div class="other-ball"></div></div>
    </div>

    <div id="right_hud">
        <div id="guide_circle_right"><div class="other-ball"></div></div>
    </div>
    <div id="container"><button id="goFS" style="display:block"> </button></div>
    <script src="../build/three.js"></script>
    <script src="js/controls/DeviceOrientationControls.js"></script>
    <script src="js/controls/PointerLockControls.js"></script>
    <script src="js/loaders/VRMLLoader.js"></script>
    <script src="js/loaders/SVGLoader.js"></script>

    <script src="js/utils/BufferGeometryUtils.js"></script>

    <script src="js/renderers/Projector.js"></script>
    <script src="js/shaders/NormalMapShader.js"></script>
    <script src="js/ShaderTerrain.js"></script>

    <script src="js/Detector.js"></script>
    <script src="js/postprocessing/EffectComposer.js"></script>
    <script src="js/postprocessing/RenderPass.js"></script>
    <script src="js/postprocessing/MaskPass.js"></script>
    <script src="js/postprocessing/ShaderPass.js"></script>
    <script src="js/shaders/CopyShader.js"></script>

    <script id="fragmentShaderNoise" type="x-shader/x-fragment">

      //
      // Description : Array and textureless GLSL 3D simplex noise function.
      //      Author : Ian McEwan, Ashima Arts.
      //  Maintainer : ijm
      //     Lastmod : 20110409 (stegu)
      //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
      //               Distributed under the MIT License. See LICENSE file.
      //

      uniform float time;
      varying vec2 vUv;

      vec4 permute(vec4 x) {
        return mod(((x * 34.0) + 1.0) * x, 289.0);
      }

      vec4 taylorInvSqrt(vec4 r) {
        return 1.79284291400159 - 0.85373472095314 * r;
      }

      float snoise(vec3 v) {
        const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);
        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

        // First corner
        vec3 i  = floor(v + dot(v, C.yyy));
        vec3 x0 = v - i + dot(i, C.xxx);

        // Other corners
        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min(g.xyz, l.zxy);
        vec3 i2 = max(g.xyz, l.zxy);

        vec3 x1 = x0 - i1 + 1.0 * C.xxx;
        vec3 x2 = x0 - i2 + 2.0 * C.xxx;
        vec3 x3 = x0 - 1. + 3.0 * C.xxx;

        // Permutations
        i = mod(i, 289.0);
        vec4 p = permute(permute(permute(
             i.z + vec4(0.0, i1.z, i2.z, 1.0))
             + i.y + vec4(0.0, i1.y, i2.y, 1.0))
             + i.x + vec4(0.0, i1.x, i2.x, 1.0));

        // Gradients
        // (N*N points uniformly over a square, mapped onto an octahedron.)
        float n_ = 1.0 / 7.0; // N=7

        vec3 ns = n_ * D.wyz - D.xzx;

        vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)

        vec4 x_ = floor(j * ns.z);
        vec4 y_ = floor(j - 7.0 * x_);    // mod(j,N)

        vec4 x = x_ *ns.x + ns.yyyy;
        vec4 y = y_ *ns.x + ns.yyyy;
        vec4 h = 1.0 - abs(x) - abs(y);

        vec4 b0 = vec4(x.xy, y.xy);
        vec4 b1 = vec4(x.zw, y.zw);

        vec4 s0 = floor(b0) * 2.0 + 1.0;
        vec4 s1 = floor(b1) * 2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));

        vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
        vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

        vec3 p0 = vec3(a0.xy, h.x);
        vec3 p1 = vec3(a0.zw, h.y);
        vec3 p2 = vec3(a1.xy, h.z);
        vec3 p3 = vec3(a1.zw, h.w);

        // Normalise gradients
        vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
        p0 *= norm.x;
        p1 *= norm.y;
        p2 *= norm.z;
        p3 *= norm.w;

        // Mix final noise value
        vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);

        m = m * m;

        return 42.0 *
          dot(
              m*m,
              vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3))
            );
      }

      float surface3(vec3 coord) {
        float n = 0.0;

        n += 1.0 * abs(snoise(coord));
        n += 0.5 * abs(snoise(coord * 2.0));
        n += 0.25 * abs(snoise(coord * 4.0));
        n += 0.125 * abs(snoise(coord * 8.0));

        return n;
      }

      void main(void) {
        float n = surface3(vec3(vUv, -time));

        gl_FragColor = vec4(vec3(n, n, n), 1.0);
      }
    </script>

    <script id="vertexShader" type="x-shader/x-vertex">
      varying vec2 vUv;
      uniform vec2 scale;
      uniform vec2 offset;

      void main(void) {
        vUv = uv * scale + offset;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    </script>

    <script>

      if(!Detector.webgl) {
        Detector.addGetWebGLMessage();
      }

      var SCREEN_WIDTH = window.innerWidth;
      var SCREEN_HEIGHT = window.innerHeight;

      var renderer, container, stats;

      var usingPhone = false;
      var updateNoise = true;
      var notInited = true;

      var camera, scene, controls, effect;
      var stereoCamera;
      var cameraOrtho2, cameraOrtho, sceneRenderTarget;
      var yawObject;

      var uniformsNoise, uniformsNormal, uniformsTerrain,
        heightMap, normalMap, quadTarget;

      var foobar = 0;
      var foobar2 = true;
      var baz = 0;

      var directionalLight, pointLight;

      var terrain;
      var geometryTerrain;

      var skyCube, skyBox;

      var animDelta = 0, animDeltaDir = -1;
      var lightVal = 0, lightDir = 1;

      var clock = new THREE.Clock();
      var prevTime = performance.now();

      var updateDistortionEffect;

      var animateTerrain = false;

      var mlib = {};  //library of materials

      var moveForward = false;
      var moveBackward = false;
      var moveLeft = false;
      var moveRight = false;

      var raycaster = new THREE.Raycaster();;
      var velocity = new THREE.Vector3();
      var direction = new THREE.Vector3();

      var arrowObjs = [];
      var selectableObjs = [];

      var dangle = 0;
      var dangleChange = 0;
      
      var recenterTimeout;
      var recenterState = 0;

      var up = new THREE.Vector3(0, 1, 0);
      var minusZed = new THREE.Vector3(0, 0, -1);
      var allZeros = new THREE.Vector3(0, 0, 0);
      var halfPi = Math.PI/2;
      var minusHalfPi = - halfPi;

      init();
      animate();

      function init() {
        
        Array.prototype.forEach.call(document.getElementsByClassName('other-ball'), item => {
          item.style.backgroundColor = '#ffff';
        });
        
        var goFS = document.getElementById("goFS");
        var docEl = window.document.documentElement;
        goFS.style.display = 'none';
        docEl.addEventListener("click", function() {
          fullscreen(docEl);
        }, false);
        /*
        var notify = function(e) {
          if(goFS.style.display == 'block') {
            goFS.style.display = 'none';
          }
          else {
            goFS.style.display = 'block';
          }
        };

        document.addEventListener("fullscreenchange", notify);
        document.addEventListener("webkitfullscreenchange", notify);
        document.addEventListener("mozfullscreenchange", notify);
        document.addEventListener("MSFullscreenChange", notify);
        */

        // SCENE (RENDER TARGET)
        sceneRenderTarget = new THREE.Scene();

        cameraOrtho = new THREE.OrthographicCamera(
            SCREEN_WIDTH / -2,
            SCREEN_WIDTH / 2,
            SCREEN_HEIGHT / 2,
            SCREEN_HEIGHT / -2,
            -10000,
            10000
          );

        cameraOrtho.position.z = 100;
        sceneRenderTarget.add(cameraOrtho);

        cameraOrtho2 = new THREE.OrthographicCamera(
            SCREEN_WIDTH / -2,
            SCREEN_WIDTH / 2,
            SCREEN_HEIGHT / 2,
            SCREEN_HEIGHT / -2,
            -10000,
            10000
          );

        cameraOrtho2.position.y = 2000;
        cameraOrtho2.rotation.x = minusHalfPi;

        // RENDERER
        renderer = new THREE.WebGLRenderer({ antialiasing: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
        document.getElementById('container').appendChild(renderer.domElement);

        // SCENE (FINAL)
        scene = new THREE.Scene();

        // CAMERA
        camera = new THREE.PerspectiveCamera(100, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 1000000);
        scene.add(camera);

        stereoCamera = new THREE.StereoCamera();
        stereoCamera.eyeSep = 0.07;

        composer = new THREE.EffectComposer(renderer);
        renderPass = new THREE.RenderPass(scene, stereoCamera.cameraL);
        composer.addPass(renderPass);

        effect = new THREE.ShaderPass(getDistortionShaderDefinition());
        composer.addPass(effect);
        effect.renderToScreen = true;

        updateDistortionEffect = setupDistortionEffectAndGUI(effect);
        updateDistortionEffect(camera);

        // FOG AND LIGHTS
        scene.fog = new THREE.Fog(0x9fa2ee, 0, 6300);
        scene.add(new THREE.AmbientLight(0x111111));

        directionalLight = new THREE.DirectionalLight(0xffffff, 4);
        directionalLight.position.set(500, 2000, 0);
        scene.add(directionalLight);

        pointLight = new THREE.PointLight(0xff7f00, 2);
        pointLight.position.set(0, 0, 0);
        scene.add(pointLight);

        //CONTROLS
        controls = new THREE.PointerLockControls(camera);
        scene.add(controls.getObject());

        function setOrientationControls(e) {
          window.removeEventListener('deviceorientation', setOrientationControls, true);

          if (!e.alpha) {
              return;
          }

          usingPhone = true;

          yawObject = new THREE.Object3D();

          controls = new THREE.DeviceOrientationControls(yawObject);
        }

        window.addEventListener('deviceorientation', setOrientationControls, true);

        //initTerrain();

        initLevel();

        initVRControls();

        drawSimpleSkybox();

        // EVENTS
        onWindowResize();

        window.addEventListener('resize', onWindowResize, false);
        document.addEventListener('keydown', onKeyDown, false);
        document.addEventListener('keyup', onKeyUp, false);
        document.addEventListener('mousedown', onMouseDown, false);
        document.addEventListener('mouseup', onMouseUp, false);
      }

      function drawSimpleSkybox() {
        // define path and box sides images
        var path = 'skybox/';
        var sides = [
            path + 'sbox_px.jpg',
            path + 'sbox_nx.jpg',
            path + 'sbox_py.jpg',
            path + 'sbox_ny.jpg',
            path + 'sbox_pz.jpg',
            path + 'sbox_nz.jpg'
          ];

        // load images
        skyCube = THREE.ImageUtils.loadTextureCube(sides);
        skyCube.format = THREE.RGBFormat;

        // prepare skybox material (shader)
        var skyShader = THREE.ShaderLib["cube"];

        skyShader.uniforms["tCube"].value = skyCube;

        var skyMaterial = new THREE.ShaderMaterial( {
            fragmentShader: skyShader.fragmentShader,
            vertexShader: skyShader.vertexShader,
            uniforms: skyShader.uniforms,
            depthWrite: false,
            side: THREE.BackSide
          });

        // create Mesh with cube geometry and add to the scene
        skyBox = new THREE.Mesh(new THREE.BoxGeometry(12000, 12000, 12000), skyMaterial);
        skyMaterial.needsUpdate = true;

        skyBox.UserData = {
            name:"skyBox"
          };

        scene.add(skyBox);
      }

      function initTerrain() {
        // HEIGHT + NORMAL MAPS
        var normalShader = THREE.NormalMapShader;

        var rx = 256, ry = 256;
        var pars = {
          minFilter: THREE.LinearFilter,
          magFilter: THREE.LinearFilter,
          format: THREE.RGBFormat
        };

        heightMap = new THREE.WebGLRenderTarget(rx, ry, pars);
        heightMap.texture.generateMipmaps = false;

        normalMap = new THREE.WebGLRenderTarget(rx, ry, pars);
        normalMap.texture.generateMipmaps = false;

        uniformsNoise = {
          time: {
            value: 1.0
          },
          scale: {
            value: new THREE.Vector2(1, 1)
          },
          offset: {
            value: new THREE.Vector2(0, 0)
          }
        };

        uniformsNormal = THREE.UniformsUtils.clone(normalShader.uniforms);

        uniformsNormal.height.value = 0.05;
        uniformsNormal.resolution.value.set(rx, ry);
        uniformsNormal.heightMap.value = heightMap.texture;

        var vertexShader = document.getElementById('vertexShader').textContent;

        // TEXTURES
        var loadingManager = new THREE.LoadingManager(function() {
          terrain.visible = true;
        });

        var textureLoader = new THREE.TextureLoader(loadingManager);

        var specularMap = new THREE.WebGLRenderTarget(2048, 2048, pars);
        specularMap.texture.generateMipmaps = false;

        var diffuseTexture1 = textureLoader.load("textures/terrain/grasslight-big3.jpg");
        var diffuseTexture2 = textureLoader.load("textures/terrain/grasslight-big2.jpg");
        var detailTexture = textureLoader.load("textures/terrain/grasslight-big-nm.jpg");

        diffuseTexture1.wrapS = diffuseTexture1.wrapT = THREE.RepeatWrapping;
        diffuseTexture2.wrapS = diffuseTexture2.wrapT = THREE.RepeatWrapping;
        detailTexture.wrapS = detailTexture.wrapT = THREE.RepeatWrapping;
        specularMap.texture.wrapS = specularMap.texture.wrapT = THREE.RepeatWrapping;

        // TERRAIN SHADER
        var terrainShader = THREE.ShaderTerrain["terrain"];

        uniformsTerrain = THREE.UniformsUtils.clone(terrainShader.uniforms);

        uniformsTerrain['tNormal'].value = normalMap.texture;
        uniformsTerrain['uNormalScale'].value = 1;

        uniformsTerrain['tDisplacement'].value = heightMap.texture;

        uniformsTerrain['tDiffuse1'].value = diffuseTexture1;
        uniformsTerrain['tDiffuse2'].value = diffuseTexture2;
        uniformsTerrain['tSpecular'].value = specularMap.texture;
        uniformsTerrain['tDetail'].value = detailTexture;

        uniformsTerrain['enableDiffuse1'].value = true;
        uniformsTerrain['enableDiffuse2'].value = true;
        uniformsTerrain['enableSpecular'].value = true;

        uniformsTerrain['diffuse'].value.setHex(0x7f7f7f);
        uniformsTerrain['specular'].value.setHex(0xffffff);

        uniformsTerrain['shininess'].value = 30;

        uniformsTerrain['uDisplacementScale'].value = 0;

        uniformsTerrain['uRepeatOverlay'].value.set(40,40);

        var params = [
          ['heightmap', document.getElementById('fragmentShaderNoise').textContent, vertexShader, uniformsNoise, false],
          ['normal', normalShader.fragmentShader, normalShader.vertexShader, uniformsNormal, false],
          ['terrain', terrainShader.fragmentShader, terrainShader.vertexShader, uniformsTerrain, true]
        ];

        for(var i = 0; i < params.length; i ++) {
          var material = new THREE.ShaderMaterial({
              uniforms:       params[i][3],
              vertexShader:   params[i][2],
              fragmentShader: params[i][1],
              lights:         params[i][4],
              fog:            true
            });

          mlib[params[i][0]] = material;
        }

        var plane = new THREE.PlaneBufferGeometry(SCREEN_WIDTH, SCREEN_HEIGHT);

        quadTarget = new THREE.Mesh(plane, new THREE.MeshBasicMaterial({ color: 0x000000 }));
        quadTarget.position.z = -500;
        sceneRenderTarget.add(quadTarget);

        // TERRAIN MESH
        geometryTerrain = new THREE.PlaneBufferGeometry(6000, 6000, 256, 256);

        geometryTerrain.verticesNeedUpdate = true;
        geometryTerrain.normalsNeedUpdate = true;
        geometryTerrain.computeVertexNormals();
        geometryTerrain.computeFaceNormals();
        geometryTerrain.computeBoundingBox();

        THREE.BufferGeometryUtils.computeTangents(geometryTerrain);

        terrain = new THREE.Mesh(geometryTerrain, mlib['terrain']);
        terrain.position.set(0, 0, 0);
        terrain.rotation.x = -Math.PI / 2;
        terrain.rotation.z = Math.PI / 2;
        terrain.visible = false;
        scene.add(terrain);
      }

      function applyDisplacementMap(mesh, renderer, target, minHeight, maxHeight) {
        var uvs = mesh.geometry.attributes.uv.array;
        var positions = mesh.geometry.attributes.position.array;
        var normals = mesh.geometry.attributes.normal.array;
        var position = new THREE.Vector3();
        var normal = new THREE.Vector3();
        var uv = new THREE.Vector2();

        var width = target.width;
        var height = target.height;

        var buffer = new Uint8Array((4 * (width * height)));
        renderer.readRenderTargetPixels(target, 0, 0, width, height, buffer);

        for(var index = 0; index < positions.length; index+=3) {
          position.fromArray(positions,index);

          normal.fromArray(normals,index);
          uv.fromArray(uvs,(index/1.5)||0);

          var u = Math.min((Math.abs(uv.x)*width),width-1);
          var v = Math.min((Math.abs(uv.y)*height),height-1);

          var pos = (u+v*width) * 3;
          normal.normalize().multiplyScalar(minHeight + (maxHeight - minHeight) * buffer[pos] / 255.0);
          position = position.add(normal);
          position.toArray(positions, index);
        }

        mesh.geometry.needsUpdate = true;
      }

      function initLevel() {
        terrain = {
          visible :false
        };

        var loader = new THREE.VRMLLoader();

        loader.load('e1m1.wrl', function (object) {
            terrain = object;
            terrain.position.set(170,-12.5,595);
            terrain.scale.set(5,6,5);

            rotateAboutPoint(terrain, allZeros, up, Math.PI, false);

            scene.add(terrain);

            terrain.visible = true;
          });
      }

      function initVRControls() {
        // VR CONTROLS
        var loader = new THREE.SVGLoader();

        [
          'models/svg/up2.svg',
          'models/svg/down2.svg',
          'models/svg/left2.svg',
          'models/svg/right2.svg',
          'models/svg/sleft2.svg',
          'models/svg/sright2.svg',
          'models/svg/recenter2.svg',
          'models/svg/up1.svg',
          'models/svg/down1.svg',
          'models/svg/left1.svg',
          'models/svg/right1.svg',
          'models/svg/sleft1.svg',
          'models/svg/sright1.svg',
          'models/svg/recenter1.svg',
        ].
        forEach((currentValue, index) => {
          loader.load(currentValue, svgCallback.bind(null, index));
        });
      }

      function svgCallback(objectNumber, paths) {
        var group = new THREE.Group();

        group.rotation.x = minusHalfPi;
        group.scale.set(0.1, -0.1, 0.1);

        for(var i = 0; i < paths.length; i++) {
          var path = paths[i];

          var material = new THREE.MeshBasicMaterial({
              color: path.color,
              side: THREE.DoubleSide,
              depthWrite: false,
              depthTest: objectNumber >6,
              transparent: true,
              opacity: objectNumber > 6 ? 0.15 : 0
            });

          var shapes = path.toShapes(true);

          for(var j = 0; j < shapes.length; j++) {
            var shape = shapes[j];

            var geometry = new THREE.ShapeBufferGeometry(shape);
            var mesh = new THREE.Mesh(geometry, material);

            group.add(mesh);
          }
        }

        group.name = objectNumber;

        arrowObjs[objectNumber] = group;

        if(objectNumber < 7) {
          selectableObjs[objectNumber] = group;
        }

        scene.add(group);

        return group;
      }

      function setupDistortionEffectAndGUI(effect) {
        var guiParameters = {
          horizontalFOV:    75,
          strength:         0.56,
          cylindricalRatio: 1.7,
        }, height;

        return camera => {
          height = Math.tan(THREE.Math.degToRad(guiParameters.horizontalFOV) / 2) / camera.aspect;

          camera.fov = Math.atan(height) * 2 * 180 / 3.1415926535;
          camera.updateProjectionMatrix();

          effect.uniforms[ "strength" ].value = guiParameters.strength;
          effect.uniforms[ "height" ].value = height;
          effect.uniforms[ "aspectRatio" ].value = camera.aspect;
          effect.uniforms[ "cylindricalRatio" ].value = guiParameters.cylindricalRatio;
        };
      }

      function getDistortionShaderDefinition() {
        return {
            uniforms: {
                "tDiffuse":         { type: "t", value: null },
                "strength":         { type: "f", value: 0 },
                "height":           { type: "f", value: 1 },
                "aspectRatio":      { type: "f", value: 1 },
                "cylindricalRatio": { type: "f", value: 1 }
            },

            vertexShader: [
                "uniform float strength;",          // s: 0 = perspective, 1 = stereographic
                "uniform float height;",            // h: tan(verticalFOVInRadians / 2)
                "uniform float aspectRatio;",       // a: screenWidth / screenHeight
                "uniform float cylindricalRatio;",  // c: cylindrical distortion ratio. 1 = spherical

                "varying vec3 vUV;",                // output to interpolate over screen
                "varying vec2 vUVDot;",             // output to interpolate over screen

                "void main() {",
                    "gl_Position = projectionMatrix * (modelViewMatrix * vec4(position, 1.0));",

                    "float scaledHeight = strength * height;",
                    "float cylAspectRatio = aspectRatio * cylindricalRatio;",
                    "float aspectDiagSq = aspectRatio * aspectRatio + 1.0;",
                    "float diagSq = scaledHeight * scaledHeight * aspectDiagSq;",
                    "vec2 signedUV = (2.0 * uv + vec2(-1.0, -1.0));",

                    "float z = 0.5 * sqrt(diagSq + 1.0) + 0.5;",
                    "float ny = (z - 1.0) / (cylAspectRatio * cylAspectRatio + 1.0);",

                    "vUVDot = sqrt(ny) * vec2(cylAspectRatio, 1.0) * signedUV;",
                    "vUV = vec3(0.5, 0.5, 1.0) * z + vec3(-0.5, -0.5, 0.0);",
                    "vUV.xy += uv;",
                "}"
            ].join("\n"),

            fragmentShader: [
                "uniform sampler2D tDiffuse;",      // sampler of rendered scene?s render target
                "varying vec3 vUV;",                // interpolated vertex output data
                "varying vec2 vUVDot;",             // interpolated vertex output data

                "void main() {",
                    "vec3 uv = dot(vUVDot, vUVDot) * vec3(-0.5, -0.5, -1.0) + vUV;",
                    "gl_FragColor = texture2DProj(tDiffuse, uv);",
                "}"
            ].join("\n")
        };
      }

      function onKeyDown(event) {
        switch(event.keyCode) {
          case 78: { /*N*/
            lightDir *= -1;
          } break;

          case 77: { /*M*/
            animDeltaDir *= -1;
          } break;

          case 38: // up
          case 87: { // w
            moveForward = true;
          } break;

          case 37: // left
          case 65: { // a
            moveLeft = true;
          } break;

          case 40: // down
          case 83: { // s
            moveBackward = true;
          } break;

          case 39: // right
          case 68: { // d
            moveRight = true;
          } break;
        }
      }

      function onKeyUp(event) {
        switch(event.keyCode) {
          case 38: // up
          case 87: { // w
            moveForward = false;
          } break;

          case 37: // left
          case 65: { // a
            moveLeft = false;
            } break;

          case 40: // down
          case 83: { // s
            moveBackward = false;
          } break;

          case 39: // right
          case 68: { // d
            moveRight = false;
          } break;
        }
      }

      function onMouseDown() {
        if(!usingPhone) {
          controls.enabled = true; // Turns on camera rotating with mouse
        }
      }

      function onMouseUp() {
        if(!usingPhone) {
          controls.enabled = false; // Turns on camera rotating with mouse
        }
      }

      function onWindowResize(event) {
        SCREEN_WIDTH = window.innerWidth;
        SCREEN_HEIGHT = window.innerHeight;

        camera.aspect = (SCREEN_WIDTH/2) / SCREEN_HEIGHT;

        renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
        composer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);

        updateDistortionEffect(stereoCamera.cameraL);
      }

      function fullscreen(container) {
        if(container.requestFullscreen) {
          container.requestFullscreen();
        }
        else if(container.msRequestFullscreen) {
          container.msRequestFullscreen();
        }
        else if(container.mozRequestFullScreen) {
          container.mozRequestFullScreen();
        }
        else if(container.webkitRequestFullscreen) {
          container.webkitRequestFullscreen();
        }
      }

      function rotateAboutPoint(obj, point, axis, theta, pointIsWorld){
        pointIsWorld = (pointIsWorld === undefined)? false : pointIsWorld;

        if(pointIsWorld){
          obj.parent.localToWorld(obj.position); // compensate for world coordinate
        }

        obj.position.sub(point); // remove the offset
        obj.position.applyAxisAngle(axis, theta); // rotate the POSITION
        obj.position.add(point); // re-add the offset

        if(pointIsWorld){
          obj.parent.worldToLocal(obj.position); // undo world coordinates compensation
        }

        obj.rotateOnAxis(axis, theta); // rotate the OBJECT
      }

      function getIntersections(objects) {
        var vector = minusZed.clone();

        if(usingPhone) {
          vector
            .applyQuaternion(camera.quaternion)

          raycaster.set(camera.position, vector);
        }
        else {
          vector
            .applyQuaternion(controls.getObject().children[0].quaternion)
            .applyQuaternion(controls.getObject().quaternion)

          raycaster.set(controls.getObject().position, vector);
        }

        return raycaster.intersectObjects(objects, true);
      }
      
      function reCenter1() {
        recenterState = 2;
        
        Array.prototype.forEach.call(document.getElementsByClassName('other-ball'), item => {
          item.style.backgroundColor = '#000000';
        });
        
        recenterTimeout = setTimeout(reCenter2, 4000);
      }
      
      function reCenter2() {
        if(!usingPhone) {
          dangle = controls.getObject().rotation.y;
        }
        else {
          var rotation = foobar + dangle;
          var rotation2 = minusZed
.clone()
.applyQuaternion(yawObject.quaternion.conjugate())
.applyAxisAngle(up, rotation);

           rotation2.y = 0;





         // alert(camera.rotation.y)
          dangle = minusZed.angleTo(rotation2);
          if (camera.rotation.y< 0) {
            dangle *= -1;
          }


          foobar = rotation-dangle;
        }
        
        Array.prototype.forEach.call(document.getElementsByClassName('other-ball'), item => {
          item.style.backgroundColor = '#ffffff';
        });
        
        recenterState = 0;
      }

      function animate() {
        requestAnimationFrame(animate);

        var time = performance.now();
        var delta = (time - prevTime) / 1000;

        if(true) { //terrain.visible) {
          if(updateNoise) {
            //animDelta = THREE.Math.clamp(animDelta + 0.00075 * animDeltaDir, 0, 0.05);
            //uniformsNoise['time'].value += delta * animDelta;

            //uniformsNoise['offset'].value.x += delta * 0.05;

            //uniformsTerrain['uOffset'].value.x = 4 * uniformsNoise['offset'].value.x;

            //quadTarget.material = mlib['heightmap'];
            //renderer.render(sceneRenderTarget, cameraOrtho, heightMap, true);
            //applyDisplacementMap(terrain, renderer, heightMap, 0, 600);

            //quadTarget.material = mlib['normal'];

            //renderer.render(sceneRenderTarget, cameraOrtho, normalMap, true);

            baz = ((window.orientation < 1) ? minusHalfPi : halfPi);
            foobar = baz;


            renderer.render(scene, camera);
            updateNoise = false;
          }
          else {
            var obj = usingPhone ? camera : controls.getObject();

            if(usingPhone) {
              controls.update();

              var rotation = new THREE.Euler().setFromQuaternion(yawObject.quaternion, 'XYZ');

              camera.rotation.set(rotation.x, rotation.y, rotation.z);
              camera.rotateOnAxis(up.clone().applyQuaternion(yawObject.quaternion.conjugate()), foobar+dangle);
            }

            stereoCamera.update(camera);

            renderer.setScissorTest(true);

            renderer.setScissor(0, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT);
            renderer.setViewport(0, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT);
            renderPass.camera = stereoCamera.cameraL; //note: bending rule by setting RenderPass.camera directly without set/get methods
            composer.render();

            renderer.setScissor(SCREEN_WIDTH / 2, 0, SCREEN_WIDTH / 2, SCREEN_WIDTH);
            renderer.setViewport(SCREEN_WIDTH / 2, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT);
            renderPass.camera = stereoCamera.cameraR; //note: bending rule by setting RenderPass.camera directly without set/get methods
            composer.render();

            renderer.setScissorTest(false);
          }
        }

        var intersects;

        //velocity.x -= velocity.x * 0.5 * delta;
        //velocity.z -= velocity.z * 0.5 * delta;

        intersects = getIntersections(selectableObjs);

        var a = intersects.length ? intersects[0].object.parent.name : -1;

        switch(a) {
          case 0:
            moveForward = true;
            moveLeft = moveRight = moveBackward = false;
          break;

          case 1:
            moveBackward = true;
            moveLeft = moveRight = moveForward = false;
          break;
          
          case 4:
            moveLeft = true;
            moveRight = moveForward = moveBackward = false;
          break;

          case 5:
            moveRight = true;
            moveLeft = moveForward = moveBackward = false;
          break;

          default:
            moveRight =
            moveLeft =
            moveForward =
            moveBackward =
            false;
          break;
        }
        
        switch(a) {
          case 2:
            dangleChange = Math.min(0.005, dangleChange + 0.0025 * delta);
            dangle += dangleChange;

            if(!usingPhone) {
              obj.rotation.y += dangleChange;
            }
          break;

          case 3:
            dangleChange = Math.min(0.005, dangleChange + 0.0025 * delta);
            dangle -= dangleChange;

            if(!usingPhone) {
              obj.rotation.y -= dangleChange;
            }
          break;
          
          default:
            dangleChange = 0;
          break;
        }
        
        if(a == 6) {
          if(recenterState == 0) {
            recenterTimeout = setTimeout(reCenter1, 3000);
            recenterState = 1;
          }
        }
        else {
          if(recenterState == 1) {
            clearTimeout(recenterTimeout);
            recenterState = 0;
          }
        }
        

        for(var i = 7; i < 14; i++) {
          if(arrowObjs[i]) {
            arrowObjs[i].children[0].material.opacity = a=== i-7 ? .5: 0.15;
            arrowObjs[i].children[1].material.opacity = a=== i-7 ? .5: 0.15;

            if(arrowObjs[i].children[2]) {
              arrowObjs[i].children[2].material.opacity = a=== i-7 ? .5: 0.15;
            }
          }
        }

        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveLeft) - Number(moveRight);

        direction.normalize().applyAxisAngle(up, dangle);

        if(moveRight || moveLeft || moveForward || moveBackward) {
          velocity.z += (direction.z * 0.15 * delta);
          velocity.x += (direction.x * 0.15 * delta);

          velocity.clampLength(0, 3);
        }
        else {
          velocity.x = 0;
          velocity.z = 0;
        }

        if(true){//notInited || moveForward || moveBackward || moveLeft || moveRight) {
          //cameraOrtho2.position.x = cameraOrtho2.position.x - velocity.x;
          //cameraOrtho2.position.z = cameraOrtho2.position.z - velocity.z;
          //cameraOrtho2.updateProjectionMatrix();

          // Set the raycaster position
          //raycaster.set(
          //    cameraOrtho2.position,
          //    new THREE.Vector3(0, -1, 0)
          //  );

          //var intersects = raycaster.intersectObjects([terrain]);

          if(true) {//intersects.length) {
            for(var i = 0; i < 14; i++) {
              if(arrowObjs[i]) {
                arrowObjs[i].position.x = obj.position.x;
                arrowObjs[i].position.y = obj.position.y - 12;
                arrowObjs[i].position.z = obj.position.z - 10;

                var thoob = new THREE.Vector3(arrowObjs[i].position.x, arrowObjs[i].position.y, arrowObjs[i].position.z+10);

                arrowObjs[i].position.sub(thoob); // remove the offset
                arrowObjs[i].position.applyAxisAngle(up, dangle); // rotate the POSITION
                arrowObjs[i].rotation.z = dangle;
                arrowObjs[i].position.add(thoob); // re-add the offset
              }
            }

            skyBox.position.x = obj.position.x;
            skyBox.position.y = obj.position.y;
            skyBox.position.z = obj.position.z;

            obj.position.set(
              obj.position.x - velocity.x,
              0,//2130 - intersects[0].distance,
              obj.position.z - velocity.z
            );

            notInited = false;
          }
          else {
            cameraOrtho2.position.x = obj.position.x;
            cameraOrtho2.position.z = obj.position.z;
          }
        }

        prevTime = time;
      }
    </script>

  </body>
</html>
