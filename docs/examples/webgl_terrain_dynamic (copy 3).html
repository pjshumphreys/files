<!DOCTYPE HTML>
<html lang="en">
	<head>
		<title>three.js webgl - dynamic procedural terrain</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style type="text/css">
			body {
				background: #000;
				color: #999;
				padding: 0;
				margin: 0;
				overflow: hidden;
				font-family: georgia;
				font-size:1em;
				text-align: center;
			}

			#info { position: absolute; top: 10px; width: 100%; }

			a { color: #fb0; }

			#footer { position: absolute; bottom: 10px; width: 100%; }
			.h { color: #fb0 }
			.c { display: inline; margin-left: 1em }

		</style>
	</head>

	<body>
		<div id="container"></div>

		<div id="info">
			<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - dynamic procedural terrain using
			<a href="https://github.com/ashima/webgl-noise" target="_blank" rel="noopener">3d simplex noise</a><br/>
			textures by <a href="http://opengameart.org/content/dark-grass">qubodup</a> and
			<a href="http://opengameart.org/content/backgrounds-topdown-games">davis123</a>
		</div>

		<div id="footer">
			<div class="c">
			day / night: <span class="h">n</span>
			</div>

			<div class="c">
			animate terrain: <span class="h">m</span>
			</div>
		</div>

		<script src="../build/three.js"></script>

		<script src="js/controls/OrbitControls.js"></script>

		<script src="js/utils/BufferGeometryUtils.js"></script>

		<script src="js/renderers/Projector.js"></script>
		<script src="js/shaders/NormalMapShader.js"></script>
		<script src="js/ShaderTerrain.js"></script>

		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<script id="fragmentShaderNoise" type="x-shader/x-fragment">

			//
			// Description : Array and textureless GLSL 3D simplex noise function.
			//      Author : Ian McEwan, Ashima Arts.
			//  Maintainer : ijm
			//     Lastmod : 20110409 (stegu)
			//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
			//               Distributed under the MIT License. See LICENSE file.
			//

			uniform float time;
			varying vec2 vUv;

			vec4 permute( vec4 x ) {

				return mod( ( ( x * 34.0 ) + 1.0 ) * x, 289.0 );

			}

			vec4 taylorInvSqrt( vec4 r ) {

				return 1.79284291400159 - 0.85373472095314 * r;

			}

			float snoise( vec3 v ) {

				const vec2 C = vec2( 1.0 / 6.0, 1.0 / 3.0 );
				const vec4 D = vec4( 0.0, 0.5, 1.0, 2.0 );

				// First corner

				vec3 i  = floor( v + dot( v, C.yyy ) );
				vec3 x0 = v - i + dot( i, C.xxx );

				// Other corners

				vec3 g = step( x0.yzx, x0.xyz );
				vec3 l = 1.0 - g;
				vec3 i1 = min( g.xyz, l.zxy );
				vec3 i2 = max( g.xyz, l.zxy );

				vec3 x1 = x0 - i1 + 1.0 * C.xxx;
				vec3 x2 = x0 - i2 + 2.0 * C.xxx;
				vec3 x3 = x0 - 1. + 3.0 * C.xxx;

				// Permutations

				i = mod( i, 289.0 );
				vec4 p = permute( permute( permute(
						 i.z + vec4( 0.0, i1.z, i2.z, 1.0 ) )
					   + i.y + vec4( 0.0, i1.y, i2.y, 1.0 ) )
					   + i.x + vec4( 0.0, i1.x, i2.x, 1.0 ) );

				// Gradients
				// ( N*N points uniformly over a square, mapped onto an octahedron.)

				float n_ = 1.0 / 7.0; // N=7

				vec3 ns = n_ * D.wyz - D.xzx;

				vec4 j = p - 49.0 * floor( p * ns.z *ns.z );  //  mod(p,N*N)

				vec4 x_ = floor( j * ns.z );
				vec4 y_ = floor( j - 7.0 * x_ );    // mod(j,N)

				vec4 x = x_ *ns.x + ns.yyyy;
				vec4 y = y_ *ns.x + ns.yyyy;
				vec4 h = 1.0 - abs( x ) - abs( y );

				vec4 b0 = vec4( x.xy, y.xy );
				vec4 b1 = vec4( x.zw, y.zw );


				vec4 s0 = floor( b0 ) * 2.0 + 1.0;
				vec4 s1 = floor( b1 ) * 2.0 + 1.0;
				vec4 sh = -step( h, vec4( 0.0 ) );

				vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
				vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

				vec3 p0 = vec3( a0.xy, h.x );
				vec3 p1 = vec3( a0.zw, h.y );
				vec3 p2 = vec3( a1.xy, h.z );
				vec3 p3 = vec3( a1.zw, h.w );

				// Normalise gradients

				vec4 norm = taylorInvSqrt( vec4( dot( p0, p0 ), dot( p1, p1 ), dot( p2, p2 ), dot( p3, p3 ) ) );
				p0 *= norm.x;
				p1 *= norm.y;
				p2 *= norm.z;
				p3 *= norm.w;

				// Mix final noise value

				vec4 m = max( 0.6 - vec4( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ), dot( x3, x3 ) ), 0.0 );
				m = m * m;
				return 42.0 * dot( m*m, vec4( dot( p0, x0 ), dot( p1, x1 ),
											  dot( p2, x2 ), dot( p3, x3 ) ) );

			}

			float surface3( vec3 coord ) {

				float n = 0.0;

				n += 1.0 * abs( snoise( coord ) );
				n += 0.5 * abs( snoise( coord * 2.0 ) );
				n += 0.25 * abs( snoise( coord * 4.0 ) );
				n += 0.125 * abs( snoise( coord * 8.0 ) );

				return n;

			}

			void main( void ) {

				vec3 coord = vec3( vUv, -time );
				float n = surface3( coord );

				gl_FragColor = vec4( vec3( n, n, n ), 1.0 );

			}

		</script>

		<script id="vertexShader" type="x-shader/x-vertex">

			varying vec2 vUv;
			uniform vec2 scale;
			uniform vec2 offset;

			void main( void ) {

				vUv = uv * scale + offset;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}

		</script>

		<script>
      var geometryTerrain;
      var raycaster;

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var SCREEN_WIDTH = window.innerWidth;
			var SCREEN_HEIGHT = window.innerHeight;

			var renderer, container, stats;

			var camera, scene, controls;
			var cameraOrtho2, cameraOrtho, sceneRenderTarget;

			var uniformsNoise, uniformsNormal, uniformsTerrain,
				heightMap, normalMap,
				quadTarget;

			var directionalLight, pointLight;

			var terrain;

			var textureCounter = 0;

			var animDelta = 0, animDeltaDir = -1;
			var lightVal = 0, lightDir = 1;

			var clock = new THREE.Clock();

			var updateNoise = true;

			var animateTerrain = false;

			var mlib = {};
      var mouse;

			init();
			animate();

			function init() {

				container = document.getElementById( 'container' );

				// SCENE (RENDER TARGET)

				sceneRenderTarget = new THREE.Scene();

				cameraOrtho = new THREE.OrthographicCamera( SCREEN_WIDTH / - 2, SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2, SCREEN_HEIGHT / - 2, -10000, 10000 );
				cameraOrtho2 = new THREE.OrthographicCamera( SCREEN_WIDTH / - 2, SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2, SCREEN_HEIGHT / - 2, -10000, 10000 );
				cameraOrtho2.position.y = 600;
        cameraOrtho2.rotation.x = Math.PI / -2;
				cameraOrtho.position.z = 100;

				sceneRenderTarget.add( cameraOrtho );

				// CAMERA

				camera = new THREE.PerspectiveCamera( 72, SCREEN_WIDTH / SCREEN_HEIGHT, 2, 4000 );
				//camera.position.set( 0, 200, 0 );

				controls = new THREE.OrbitControls( camera );
        /*controls.target.set(
            camera.position.x + 0.1,
            camera.position.y,
            camera.position.z
        );*/
				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;

				controls.keys = [ 65, 83, 68 ];

				// SCENE (FINAL)

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xffffff );
				scene.fog = new THREE.Fog( 0xA7A9DB, 500, 5000 );

				// LIGHTS

				scene.add( new THREE.AmbientLight( 0x111111 ) );

				directionalLight = new THREE.DirectionalLight( 0xffffff, 4 );
				directionalLight.position.set( 500, 2000, 0 );
				scene.add( directionalLight );

				pointLight = new THREE.PointLight( 0xff7f00, 2 );
				pointLight.position.set( 0, 0, 0 );
				scene.add( pointLight );


				// HEIGHT + NORMAL MAPS

				var normalShader = THREE.NormalMapShader;

				var rx = 256, ry = 256;
				var pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat };

				heightMap  = new THREE.WebGLRenderTarget( rx, ry, pars );
        heightMap.texture.generateMipmaps = false;

				normalMap = new THREE.WebGLRenderTarget( rx, ry, pars );
        normalMap.minFilter = THREE.NearestFilter;
        normalMap.magFilter = THREE.NearestFilter;
				normalMap.texture.generateMipmaps = false;

				uniformsNoise = {

					time:   { value: 1.0 },
					scale:  { value: new THREE.Vector2( 1, 1 ) },
					offset: { value: new THREE.Vector2( 0, 0 ) }

				};

				uniformsNormal = THREE.UniformsUtils.clone( normalShader.uniforms );

				uniformsNormal.height.value = 0.05;
				uniformsNormal.resolution.value.set( rx, ry );
				uniformsNormal.heightMap.value = heightMap.texture;

				var vertexShader = document.getElementById( 'vertexShader' ).textContent;

				// TEXTURES

				var loadingManager = new THREE.LoadingManager( function(){
					terrain.visible = true;
				});
				var textureLoader = new THREE.TextureLoader( loadingManager );

				var specularMap = new THREE.WebGLRenderTarget( 2048, 2048, pars );
				specularMap.texture.generateMipmaps = false;

				var diffuseTexture1 = textureLoader.load( "textures/terrain/grasslight-big3.jpg");
				var diffuseTexture2 = textureLoader.load( "textures/terrain/grasslight-big2.jpg" );
				var detailTexture = textureLoader.load( "textures/terrain/grasslight-big-nm.jpg" );

				diffuseTexture1.wrapS = diffuseTexture1.wrapT = THREE.RepeatWrapping;
				diffuseTexture2.wrapS = diffuseTexture2.wrapT = THREE.RepeatWrapping;
				detailTexture.wrapS = detailTexture.wrapT = THREE.RepeatWrapping;
				specularMap.texture.wrapS = specularMap.texture.wrapT = THREE.RepeatWrapping;

				// TERRAIN SHADER

				var terrainShader = THREE.ShaderTerrain[ "terrain" ];

				uniformsTerrain = THREE.UniformsUtils.clone( terrainShader.uniforms );

				uniformsTerrain[ 'tNormal' ].value = normalMap.texture;
				uniformsTerrain[ 'uNormalScale' ].value = 1;

				uniformsTerrain[ 'tDisplacement' ].value = heightMap.texture;

				uniformsTerrain[ 'tDiffuse1' ].value = diffuseTexture1;
				uniformsTerrain[ 'tDiffuse2' ].value = diffuseTexture2;
				uniformsTerrain[ 'tSpecular' ].value = specularMap.texture;
				uniformsTerrain[ 'tDetail' ].value = detailTexture;

				uniformsTerrain[ 'enableDiffuse1' ].value = true;
				uniformsTerrain[ 'enableDiffuse2' ].value = true;
				uniformsTerrain[ 'enableSpecular' ].value = true;

				uniformsTerrain[ 'diffuse' ].value.setHex( 0x7f7f7f );
				uniformsTerrain[ 'specular' ].value.setHex( 0xffffff );

				uniformsTerrain[ 'shininess' ].value = 30;

				uniformsTerrain[ 'uDisplacementScale' ].value = 600;

				uniformsTerrain[ 'uRepeatOverlay' ].value.set( 40,40 );

				var params = [
					[ 'heightmap', 	document.getElementById( 'fragmentShaderNoise' ).textContent, 	vertexShader, uniformsNoise, false ],
					[ 'normal', 	normalShader.fragmentShader,  normalShader.vertexShader, uniformsNormal, false ],
					[ 'terrain', 	terrainShader.fragmentShader, terrainShader.vertexShader, uniformsTerrain, true ]
				 ];

				for( var i = 0; i < params.length; i ++ ) {

					var material = new THREE.ShaderMaterial( {

						uniforms: 		params[ i ][ 3 ],
						vertexShader: 	params[ i ][ 2 ],
						fragmentShader: params[ i ][ 1 ],
						lights: 		params[ i ][ 4 ],
						fog: 			true
						} );

					mlib[ params[ i ][ 0 ] ] = material;

				}


				var plane = new THREE.PlaneBufferGeometry( SCREEN_WIDTH, SCREEN_HEIGHT );

				quadTarget = new THREE.Mesh( plane, new THREE.MeshBasicMaterial( { color: 0x000000 } ) );
				quadTarget.position.z = -500;
				sceneRenderTarget.add( quadTarget );

				// TERRAIN MESH

				geometryTerrain = new THREE.PlaneBufferGeometry( 6000, 6000, 512, 512 );

        geometryTerrain.verticesNeedUpdate = true;
        geometryTerrain.normalsNeedUpdate = true;
        geometryTerrain.computeVertexNormals();
        geometryTerrain.computeFaceNormals();
        geometryTerrain.computeBoundingBox();

				THREE.BufferGeometryUtils.computeTangents( geometryTerrain );

				terrain = new THREE.Mesh( geometryTerrain, mlib[ 'terrain' ] );
				terrain.position.set( 0, -125, 0 );
				terrain.rotation.x = -Math.PI / 2;
				terrain.visible = false;
        console.log(terrain);
				scene.add( terrain );

				// RENDERER

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
				container.appendChild( renderer.domElement );

				// STATS

				stats = new Stats();
				container.appendChild( stats.dom );


				raycaster = new THREE.Raycaster();
        
        mouse = new THREE.Vector2();

				// EVENTS

				onWindowResize();

				window.addEventListener( 'resize', onWindowResize, false );

				document.addEventListener( 'keydown', onKeyDown, false );

			}

			//

			function onWindowResize( event ) {

				SCREEN_WIDTH = window.innerWidth;
				SCREEN_HEIGHT = window.innerHeight;

				renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );

				camera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
				camera.updateProjectionMatrix();

			}

			//

			function onKeyDown ( event ) {

				switch( event.keyCode ) {

					case 78: /*N*/  lightDir *= -1; break;
					case 77: /*M*/  animDeltaDir *= -1; break;

				}

			}
      
      function heightAt (geom, x, y ) {    
        function rayTriangleIntersection( p, ray, v1, v2, v3 ) {
            let ab = new THREE.Vector3().subVectors( v2, v1 );
            let ac = new THREE.Vector3().subVectors( v3, v1 );

            let n = new THREE.Vector3().crossVectors( ab, ac );
            let d = ray.dot( n );
            if ( d <= 0 ) return false;

            let ap = new THREE.Vector3().subVectors( p, v1 );
            let t = -ap.dot( n );
            if ( t < 0 ) return false;

            let e = new THREE.Vector3().crossVectors( ray, ap );
            let u, v, w;
            v = ac.dot( e );
            if ( v < 0 || v > d ) return false;

            w = -ab.dot( e );
            if ( w < 0 || v + w > d ) return false;

            let ood = 1.0 / d;
            t *= ood;
            v *= ood;
            w *= ood;
            u = 1.0 - v - w;
            let pRay = ray.multiplyScalar( t );
            return {
                point: pRay.add( p ),
                normal: new THREE.Vector3( u, v, w )
            };
        }
    //*
        let halfSize = geom.boundingBox.max.x;
        let mapSubdiv = /*_this.mapSize*/6000 / /*_this.viewSize*/1 * /*_this.subdivisions*/512;
        let localPos = new THREE.Vector3( x, y, 0 );
        localPos.add( new THREE.Vector3( halfSize, halfSize, 0 ) );
        let t = localPos.divideScalar( halfSize * 2 );
        t.multiplyScalar( mapSubdiv );
        // Determine a 'grid' position from the local position
        let g = new THREE.Vector2( Math.floor( t.x ), Math.floor( t.y ) );
        // And determine which half of the grid square the co-ords are in
        let faceOffset = ( 1 - Frac( t.y ) <= Frac( t.x ) ) ? 1 : 0;
        // Use this to calculate the face array index.
        let idx = ( g.x + ( g.y * mapSubdiv ) ) * 2 + faceOffset;
        console.log(geom);
        //let face = geom.faces[idx];
        //if ( !face )
        //    return;
        // Then use the associated vertices to calc the intersection
        let v1 = new THREE.Vector3( 0, 0, 200 );// geom.vertices[face.a];
        let v2 = new THREE.Vector3( 1, 0, 200 );//geom.vertices[face.b];
        let v3 = new THREE.Vector3( 0, 1, 200 );//geom.vertices[face.c];

        let p = rayTriangleIntersection( new THREE.Vector3( x, -y, 0 ), new THREE.Vector3( 0, 0, 1 ), v1, v2, v3 );
        return p === false ? p : p.point.z;
    }
    
    function Frac(value) {
       return value - Math.trunc(value);
    }

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				var delta = clock.getDelta();

				if ( terrain.visible ) {

					//var fLow = 0.1, fHigh = 0.8;

					//lightVal = THREE.Math.clamp( lightVal + 0.05 * delta * lightDir, fLow, fHigh );

					//var valNorm = ( lightVal - fLow ) / ( fHigh - fLow );

					//scene.background.setHSL( 0.1, 0.5, lightVal );
					//scene.fog.color.setHSL( 0.1, 0.5, lightVal );

					//directionalLight.intensity = THREE.Math.mapLinear( valNorm, 0, 1, 0.1, 1.15 );
					//pointLight.intensity = THREE.Math.mapLinear( valNorm, 0, 1, 0.9, 1.5 );

					//uniformsTerrain[ 'uNormalScale' ].value = THREE.Math.mapLinear( valNorm, 0, 1, 0.6, 3.5 );

					
          if ( updateNoise ) {

						//animDelta = THREE.Math.clamp( animDelta + 0.00075 * animDeltaDir, 0, 0.05 );
						//uniformsNoise[ 'time' ].value += delta * animDelta;

						//uniformsNoise[ 'offset' ].value.x += delta * 0.05;

						//uniformsTerrain[ 'uOffset' ].value.x = 4 * uniformsNoise[ 'offset' ].value.x;

						quadTarget.material = mlib[ 'heightmap' ];
						renderer.render( sceneRenderTarget, cameraOrtho, heightMap, true );


            
						quadTarget.material = mlib[ 'normal' ];
						renderer.render( sceneRenderTarget, cameraOrtho, normalMap, true );
            renderer.render( scene, camera );
           // camera.position.set( 0, heightAt(geometryTerrain, 0, 0), 0 );




            updateNoise = false;

            setTimeout(function() {
              var vector = new THREE.Vector3(0, 1 , 0);

              vector.unproject(cameraOrtho2);

              // Set the raycaster position

              raycaster.set( new THREE.Vector3(0, 2000 , 0), vector.sub( new THREE.Vector3(0, 2000 , 0) ).normalize() );
            
              var intersects = raycaster.intersectObjects( [terrain] );

              if(intersects.length) {
                camera.position.set( 0, intersects[0].distance-2000+35, 0 );
                
                controls.target.set(
                    camera.position.x + 0.1,
                    camera.position.y,
                    camera.position.z
                );
              }
            },1);

          }
          else {//*/

            renderer.render( scene, camera );
          }

				}

			}

		</script>

	</body>
</html>
