<!DOCTYPE HTML>
<html lang="en">
  <head>
    <title>three.js webgl - dynamic procedural terrain</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style type="text/css">
      body {
        background: #000;
        color: #999;
        padding: 0;
        margin: 0;
        overflow: hidden;
        font-family: georgia;
        font-size:1em;
        text-align: center;
      }

      #info {
        position: absolute;
        top: 10px;
        width: 100%;
      }
      
      #goFS {
        position:absolute;
        z-index: 1;
        top: 0;
        left: 0;
        width:100%;
        height:100%;
        opacity:0;
      }

      a {
        color: #fb0;
      }

      #footer {
        position: absolute;
        bottom: 10px;
        width: 100%;
      }

      .h {
        color: #fb0;
      }

      .c {
        display: inline;
        margin-left: 1em;
      }
    </style>
  </head>

  <body><div id="container"><button id="goFS"style="display:block">Go fullscreen</button></div>
    <script src="../build/three.js"></script>
    <script src="js/effects/StereoEffect.js"></script>
    <script src="js/controls/DeviceOrientationControls.js"></script>
    <script src="js/controls/PointerLockControls.js"></script>
		<script src="js/loaders/SVGLoader.js"></script>

    <script src="js/utils/BufferGeometryUtils.js"></script>

    <script src="js/renderers/Projector.js"></script>
    <script src="js/shaders/NormalMapShader.js"></script>
    <script src="js/ShaderTerrain.js"></script>

    <script src="js/Detector.js"></script>
    <script src="js/postprocessing/EffectComposer.js"></script>
    <script src="js/postprocessing/RenderPass.js"></script>
    <script src="js/postprocessing/MaskPass.js"></script>
    <script src="js/postprocessing/ShaderPass.js"></script>
    <script src="js/shaders/CopyShader.js"></script>

    <script id="fragmentShaderNoise" type="x-shader/x-fragment">

      //
      // Description : Array and textureless GLSL 3D simplex noise function.
      //      Author : Ian McEwan, Ashima Arts.
      //  Maintainer : ijm
      //     Lastmod : 20110409 (stegu)
      //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
      //               Distributed under the MIT License. See LICENSE file.
      //

      uniform float time;
      varying vec2 vUv;

      vec4 permute(vec4 x) {
        return mod(((x * 34.0) + 1.0) * x, 289.0);
      }

      vec4 taylorInvSqrt(vec4 r) {
        return 1.79284291400159 - 0.85373472095314 * r;
      }

      float snoise(vec3 v) {
        const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);
        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

        // First corner
        vec3 i  = floor(v + dot(v, C.yyy));
        vec3 x0 = v - i + dot(i, C.xxx);

        // Other corners
        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min(g.xyz, l.zxy);
        vec3 i2 = max(g.xyz, l.zxy);

        vec3 x1 = x0 - i1 + 1.0 * C.xxx;
        vec3 x2 = x0 - i2 + 2.0 * C.xxx;
        vec3 x3 = x0 - 1. + 3.0 * C.xxx;

        // Permutations
        i = mod(i, 289.0);
        vec4 p = permute(permute(permute(
             i.z + vec4(0.0, i1.z, i2.z, 1.0))
             + i.y + vec4(0.0, i1.y, i2.y, 1.0))
             + i.x + vec4(0.0, i1.x, i2.x, 1.0));

        // Gradients
        // (N*N points uniformly over a square, mapped onto an octahedron.)
        float n_ = 1.0 / 7.0; // N=7

        vec3 ns = n_ * D.wyz - D.xzx;

        vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)

        vec4 x_ = floor(j * ns.z);
        vec4 y_ = floor(j - 7.0 * x_);    // mod(j,N)

        vec4 x = x_ *ns.x + ns.yyyy;
        vec4 y = y_ *ns.x + ns.yyyy;
        vec4 h = 1.0 - abs(x) - abs(y);

        vec4 b0 = vec4(x.xy, y.xy);
        vec4 b1 = vec4(x.zw, y.zw);

        vec4 s0 = floor(b0) * 2.0 + 1.0;
        vec4 s1 = floor(b1) * 2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));

        vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
        vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

        vec3 p0 = vec3(a0.xy, h.x);
        vec3 p1 = vec3(a0.zw, h.y);
        vec3 p2 = vec3(a1.xy, h.z);
        vec3 p3 = vec3(a1.zw, h.w);

        // Normalise gradients
        vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
        p0 *= norm.x;
        p1 *= norm.y;
        p2 *= norm.z;
        p3 *= norm.w;

        // Mix final noise value
        vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);

        m = m * m;

        return 42.0 *
          dot(
              m*m,
              vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3))
            );
      }

      float surface3(vec3 coord) {
        float n = 0.0;

        n += 1.0 * abs(snoise(coord));
        n += 0.5 * abs(snoise(coord * 2.0));
        n += 0.25 * abs(snoise(coord * 4.0));
        n += 0.125 * abs(snoise(coord * 8.0));

        return n;
      }

      void main(void) {
        float n = surface3(vec3(vUv, -time));

        gl_FragColor = vec4(vec3(n, n, n), 1.0);
      }
    </script>

    <script id="vertexShader" type="x-shader/x-vertex">
      varying vec2 vUv;
      uniform vec2 scale;
      uniform vec2 offset;

      void main(void) {
        vUv = uv * scale + offset;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    </script>

    <script>
      var geometryTerrain;
      var raycaster;

      if(!Detector.webgl) {
        Detector.addGetWebGLMessage();
      }

      var SCREEN_WIDTH = window.innerWidth;
      var SCREEN_HEIGHT = window.innerHeight;

      var renderer, container, stats;
      var usingPhone = false;

      var camera, camera2, scene, controls, effect;
      var cameraOrtho2, cameraOrtho, sceneRenderTarget;

      var uniformsNoise, uniformsNormal, uniformsTerrain,
        heightMap, normalMap,
        quadTarget;

      var directionalLight, pointLight;

      var terrain;
      
          var scCube;

      var textureCounter = 0;

      var animDelta = 0, animDeltaDir = -1;
      var lightVal = 0, lightDir = 1;

      var clock = new THREE.Clock();
      var skyBox;

      var updateNoise = true;

      var animateTerrain = false;

      var mlib = {};

      var moveForward = false;
      var moveBackward = false;
      var moveLeft = false;
      var moveRight = false;

      var velocity = new THREE.Vector3();
      var direction = new THREE.Vector3();
      var prevTime = performance.now();
      var notInited = true;
      var selectableObjs;

      var upObj, downObj, leftObj, rightObj, upBord, downBord, leftBord, rightBord;

      var goFS = document.getElementById("goFS");
      document.getElementById("goFS").style.display = 'block';
      var doc = window.document;
      var docEl = doc.documentElement;
      goFS.addEventListener("click", function() {
        fullscreen(docEl);

      }, false);

      var notify = function(e) {
        if(goFS.style.display == 'block') {
          goFS.style.display = 'none';
        }
        else {
          goFS.style.display = 'block';
        }
      };
      
      document.addEventListener("fullscreenchange", notify);
     document.addEventListener("webkitfullscreenchange", notify);
     document.addEventListener("mozfullscreenchange", notify);
     document.addEventListener("MSFullscreenChange", notify);


      init();
      //animate();

      function onMouseDown() {
        controls.enabled = true;      
      }
      
      function onMouseUp() {
        controls.enabled = false;
      }

      function init() {
        container = document.getElementById('container');

        // SCENE (RENDER TARGET)
        sceneRenderTarget = new THREE.Scene();

        cameraOrtho = new THREE.OrthographicCamera(
            SCREEN_WIDTH / -2,
            SCREEN_WIDTH / 2,
            SCREEN_HEIGHT / 2,
            SCREEN_HEIGHT / -2,
            -10000,
            10000
          );

        cameraOrtho.position.z = 100;

        cameraOrtho2 = new THREE.OrthographicCamera(
            SCREEN_WIDTH / -2,
            SCREEN_WIDTH / 2,
            SCREEN_HEIGHT / 2,
            SCREEN_HEIGHT / -2,
            -10000,
            10000
          );

        cameraOrtho2.position.y = 2000;
        cameraOrtho2.rotation.x = -Math.PI / 2;

        sceneRenderTarget.add(cameraOrtho);

        // CAMERA
        camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 1, 1000000);
        camera.rotation.y = -Math.PI / 2;

        // RENDERER
        renderer = new THREE.WebGLRenderer({ antialiasing: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
        container.appendChild(renderer.domElement);


        effect = new THREE.StereoEffect(renderer);

        // SCENE (FINAL)
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0xA7A9DB, 600, 6000);

        // LIGHTS
        scene.add(new THREE.AmbientLight(0x111111));

        directionalLight = new THREE.DirectionalLight(0xffffff, 4);
        directionalLight.position.set(500, 2000, 0);
        scene.add(directionalLight);

        pointLight = new THREE.PointLight(0xff7f00, 2);
        pointLight.position.set(0, 0, 0);
        scene.add(pointLight);

        composer = new THREE.EffectComposer( renderer );
        composer.addPass( new THREE.RenderPass( scene, camera ) );

        var effect2 = new THREE.ShaderPass( getDistortionShaderDefinition() );
        composer.addPass( effect2 );
        effect2.renderToScreen = true;

        // Setup distortion effect
        var horizontalFOV = 72;
        var strength = 0.8;
        var cylindricalRatio = 1.74;
        var height = Math.tan(THREE.Math.degToRad(horizontalFOV) / 2) / camera.aspect;

        camera.fov = Math.atan(height) * 2 * 180 / 3.1415926535;
        camera.updateProjectionMatrix();

        effect2.uniforms[ "strength" ].value = strength;
        effect2.uniforms[ "height" ].value = height;
        effect2.uniforms[ "aspectRatio" ].value = camera.aspect;
        effect2.uniforms[ "cylindricalRatio" ].value = cylindricalRatio;

        scene.add(camera);

        function setOrientationControls(e) {
          window.removeEventListener('deviceorientation', setOrientationControls, true);

          if (!e.alpha) {
              return;
          }
          
          if(!usingPhone) {
            usingPhone = true;
            
            camera.position.set(0,250,0);

            controls = new THREE.DeviceOrientationControls(camera);
          }
        }

        window.addEventListener('deviceorientation', setOrientationControls, true);


        //CONTROLS
        controls = new THREE.PointerLockControls(camera);
        scene.add(controls.getObject());

        // HEIGHT + NORMAL MAPS
        var normalShader = THREE.NormalMapShader;

        var rx = 256, ry = 256;
        var pars = {
          minFilter: THREE.LinearFilter,
          magFilter: THREE.LinearFilter,
          format: THREE.RGBFormat
        };

        heightMap = new THREE.WebGLRenderTarget(rx, ry, pars);
        heightMap.texture.generateMipmaps = false;

        normalMap = new THREE.WebGLRenderTarget(rx, ry, pars);
        normalMap.texture.generateMipmaps = false;

        uniformsNoise = {
          time: {
            value: 1.0
          },
          scale: {
            value: new THREE.Vector2(1, 1)
          },
          offset: {
            value: new THREE.Vector2(0, 0)
          }
        };

        uniformsNormal = THREE.UniformsUtils.clone(normalShader.uniforms);

        uniformsNormal.height.value = 0.05;
        uniformsNormal.resolution.value.set(rx, ry);
        uniformsNormal.heightMap.value = heightMap.texture;

        var vertexShader = document.getElementById('vertexShader').textContent;

        // TEXTURES
        var loadingManager = new THREE.LoadingManager(function() {
          terrain.visible = true;
        });

        var textureLoader = new THREE.TextureLoader(loadingManager);

        var specularMap = new THREE.WebGLRenderTarget(2048, 2048, pars);
        specularMap.texture.generateMipmaps = false;

        var diffuseTexture1 = textureLoader.load("textures/terrain/grasslight-big3.jpg");
        var diffuseTexture2 = textureLoader.load("textures/terrain/grasslight-big2.jpg");
        var detailTexture = textureLoader.load("textures/terrain/grasslight-big-nm.jpg");

        diffuseTexture1.wrapS = diffuseTexture1.wrapT = THREE.RepeatWrapping;
        diffuseTexture2.wrapS = diffuseTexture2.wrapT = THREE.RepeatWrapping;
        detailTexture.wrapS = detailTexture.wrapT = THREE.RepeatWrapping;
        specularMap.texture.wrapS = specularMap.texture.wrapT = THREE.RepeatWrapping;

        // TERRAIN SHADER
        var terrainShader = THREE.ShaderTerrain["terrain"];

        uniformsTerrain = THREE.UniformsUtils.clone(terrainShader.uniforms);

        uniformsTerrain['tNormal'].value = normalMap.texture;
        uniformsTerrain['uNormalScale'].value = 1;

        uniformsTerrain['tDisplacement'].value = heightMap.texture;

        uniformsTerrain['tDiffuse1'].value = diffuseTexture1;
        uniformsTerrain['tDiffuse2'].value = diffuseTexture2;
        uniformsTerrain['tSpecular'].value = specularMap.texture;
        uniformsTerrain['tDetail'].value = detailTexture;

        uniformsTerrain['enableDiffuse1'].value = true;
        uniformsTerrain['enableDiffuse2'].value = true;
        uniformsTerrain['enableSpecular'].value = true;

        uniformsTerrain['diffuse'].value.setHex(0x7f7f7f);
        uniformsTerrain['specular'].value.setHex(0xffffff);

        uniformsTerrain['shininess'].value = 30;

        uniformsTerrain['uDisplacementScale'].value = 0;

        uniformsTerrain['uRepeatOverlay'].value.set(40,40);

        var params = [
          ['heightmap', document.getElementById('fragmentShaderNoise').textContent, vertexShader, uniformsNoise, false],
          ['normal', normalShader.fragmentShader, normalShader.vertexShader, uniformsNormal, false],
          ['terrain', terrainShader.fragmentShader, terrainShader.vertexShader, uniformsTerrain, true]
        ];

        for(var i = 0; i < params.length; i ++) {
          var material = new THREE.ShaderMaterial({
              uniforms:       params[i][3],
              vertexShader:   params[i][2],
              fragmentShader: params[i][1],
              lights:         params[i][4],
              fog:            true
            });

          mlib[params[i][0]] = material;
        }

        var plane = new THREE.PlaneBufferGeometry(SCREEN_WIDTH, SCREEN_HEIGHT);

        quadTarget = new THREE.Mesh(plane, new THREE.MeshBasicMaterial({ color: 0x000000 }));
        quadTarget.position.z = -500;
        sceneRenderTarget.add(quadTarget);

        // TERRAIN MESH
        geometryTerrain = new THREE.PlaneBufferGeometry(6000, 6000, 256, 256);

        geometryTerrain.verticesNeedUpdate = true;
        geometryTerrain.normalsNeedUpdate = true;
        geometryTerrain.computeVertexNormals();
        geometryTerrain.computeFaceNormals();
        geometryTerrain.computeBoundingBox();

        THREE.BufferGeometryUtils.computeTangents(geometryTerrain);

        terrain = new THREE.Mesh(geometryTerrain, mlib['terrain']);
        terrain.position.set(0, 0, 0);
        terrain.rotation.x = -Math.PI / 2;
        terrain.rotation.z = Math.PI / 2;
        terrain.visible = false;
        scene.add(terrain);

        // VR CONTROLS
        var loader = new THREE.SVGLoader();
        
        Promise.all(
          [
            'models/svg/up2.svg',
            'models/svg/down2.svg',
            'models/svg/left2.svg',
            'models/svg/right2.svg',
            'models/svg/up1.svg',
            'models/svg/down1.svg',
            'models/svg/left1.svg',
            'models/svg/right1.svg'
          ].
          map((currentValue, index) => 
            (new Promise(resolve => {
              loader.load(currentValue, paths => {
                resolve(svgCallback(index, paths));
              });
            }))
          )
        ).
        then(result => {
          result.forEach(item => {
            scene.add(item);
          });
        
          selectableObjs = [upObj, downObj, leftObj, rightObj];
          
          requestAnimationFrame(animate);

          drawSimpleSkybox();

          // STATS
          //stats = new Stats();
          //container.appendChild(stats.dom);

          raycaster = new THREE.Raycaster();

          // EVENTS
          onWindowResize();

          window.addEventListener('resize', onWindowResize, false);

          document.addEventListener('keydown', onKeyDown, false);
          document.addEventListener('keyup', onKeyUp, false);
          document.addEventListener('mousedown', onMouseDown, false);
          document.addEventListener('mouseup', onMouseUp, false);
          
          animate();
        });
      }
      
          function getDistortionShaderDefinition()
    {
        return {

            uniforms: {
                "tDiffuse":         { type: "t", value: null },
                "strength":         { type: "f", value: 0 },
                "height":           { type: "f", value: 1 },
                "aspectRatio":      { type: "f", value: 1 },
                "cylindricalRatio": { type: "f", value: 1 }
            },

            vertexShader: [
                "uniform float strength;",          // s: 0 = perspective, 1 = stereographic
                "uniform float height;",            // h: tan(verticalFOVInRadians / 2)
                "uniform float aspectRatio;",       // a: screenWidth / screenHeight
                "uniform float cylindricalRatio;",  // c: cylindrical distortion ratio. 1 = spherical

                "varying vec3 vUV;",                // output to interpolate over screen
                "varying vec2 vUVDot;",             // output to interpolate over screen

                "void main() {",
                    "gl_Position = projectionMatrix * (modelViewMatrix * vec4(position, 1.0));",

                    "float scaledHeight = strength * height;",
                    "float cylAspectRatio = aspectRatio * cylindricalRatio;",
                    "float aspectDiagSq = aspectRatio * aspectRatio + 1.0;",
                    "float diagSq = scaledHeight * scaledHeight * aspectDiagSq;",
                    "vec2 signedUV = (2.0 * uv + vec2(-1.0, -1.0));",

                    "float z = 0.5 * sqrt(diagSq + 1.0) + 0.5;",
                    "float ny = (z - 1.0) / (cylAspectRatio * cylAspectRatio + 1.0);",

                    "vUVDot = sqrt(ny) * vec2(cylAspectRatio, 1.0) * signedUV;",
                    "vUV = vec3(0.5, 0.5, 1.0) * z + vec3(-0.5, -0.5, 0.0);",
                    "vUV.xy += uv;",
                "}"
            ].join("\n"),

            fragmentShader: [
                "uniform sampler2D tDiffuse;",      // sampler of rendered scene?s render target
                "varying vec3 vUV;",                // interpolated vertex output data
                "varying vec2 vUVDot;",             // interpolated vertex output data

                "void main() {",
                    "vec3 uv = dot(vUVDot, vUVDot) * vec3(-0.5, -0.5, -1.0) + vUV;",
                    "gl_FragColor = texture2DProj(tDiffuse, uv);",
                "}"
            ].join("\n")

        };
    }
      
      function onMouseDown() {
        controls.enabled = true; // Turns on camera rotating with mouse
      }
      
      function onMouseUp() {
        controls.enabled = false; // Turns on camera rotating with mouse
      }
      
      function svgCallback(objectNumber, paths) {
        var group = new THREE.Group();

        group.rotation.x = Math.PI / 2;
        group.rotation.z = Math.PI / 2;
        group.scale.set(0.865,0.95,0.95);

        for(var i = 0; i < paths.length; i++) {
          var path = paths[i];

          var material = new THREE.MeshBasicMaterial({
              color: path.color,
              side: THREE.DoubleSide,
              depthWrite: false,
              depthTest: false,
              transparent: true,
              opacity: objectNumber > 3 ? 0.15 : 0
            });

          var shapes = path.toShapes(true);

          for(var j = 0; j < shapes.length; j++) {
            var shape = shapes[j];

            var geometry = new THREE.ShapeBufferGeometry(shape);
            var mesh = new THREE.Mesh(geometry, material);

            group.add(mesh);
          }
        }
        
        switch(objectNumber) {
          case 0: {
            upObj = group;            
          }

          case 1: {
            downObj = group;            
          }

          case 2: {
            leftObj = group;            
          }

          case 3: {
            rightObj = group;            
          }

          case 4: {
            upBord = group;            
          }

          case 5: {
            downBord = group;            
          }

          case 6: {
            leftBord = group;            
          }

          case 7: {
            rightBord = group;            
          }
        }

        return group;
      }

      function fullscreen(container) {
        if (container.requestFullscreen) {
            container.requestFullscreen();
        } else if (container.msRequestFullscreen) {
            container.msRequestFullscreen();
        } else if (container.mozRequestFullScreen) {
            container.mozRequestFullScreen();
        } else if (container.webkitRequestFullscreen) {
            container.webkitRequestFullscreen();
        }
      }

      function getIntersections(objects){
        var vector = new THREE.Vector3(0, 0, -1);
        
        if(usingPhone) {
          vector
            .applyQuaternion(camera.quaternion)

          raycaster.set(camera.position, vector);
        }
        else {
          
          vector
            .applyQuaternion(controls.getObject().children[0].quaternion)
            .applyQuaternion(controls.getObject().quaternion)

          raycaster.set(controls.getObject().position, vector);
        }


        return raycaster.intersectObjects(objects, true);
      }

      function animate() {
        requestAnimationFrame(animate);
        
        if(terrain.visible) {
          if(updateNoise) {
            //animDelta = THREE.Math.clamp(animDelta + 0.00075 * animDeltaDir, 0, 0.05);
            //uniformsNoise['time'].value += delta * animDelta;

            //uniformsNoise['offset'].value.x += delta * 0.05;

            //uniformsTerrain['uOffset'].value.x = 4 * uniformsNoise['offset'].value.x;

            quadTarget.material = mlib['heightmap'];
            renderer.render(sceneRenderTarget, cameraOrtho, heightMap, true);
            applyDisplacementMap(terrain, renderer, heightMap, 0, 600);

            quadTarget.material = mlib['normal'];
            renderer.render(sceneRenderTarget, cameraOrtho, normalMap, true);
            if(usingPhone) {
              controls.update();
            }
            renderer.render(scene, camera);
            updateNoise = false;
          }
          else {
            if(usingPhone) {
              controls.update();
            }
            effect.render(scene, camera);
          }
        }

        var time = performance.now();
        var delta = (time - prevTime) / 1000;
        var intersects;

        velocity.x -= velocity.x * 5.0 * delta;
        velocity.z -= velocity.z * 5.0 * delta;
  
        intersects = getIntersections(selectableObjs);
  
        var a = intersects.length ? intersects[0].object.parent.uuid : "";
        var on =.5;

        if(a === upObj.uuid) {
          moveRight = true;
          upBord.children[0].material.opacity = on;
          upBord.children[1].material.opacity = on;
        }
        else if (moveRight) {
          moveRight = false;
          upBord.children[0].material.opacity = 0.15;
          upBord.children[1].material.opacity = 0.15;
        }
        
        if (a === downObj.uuid) {
          moveLeft = true;
          downBord.children[0].material.opacity = on;
          downBord.children[1].material.opacity = on;
        }
        else if (moveLeft) {
          moveLeft = false;
          downBord.children[0].material.opacity = 0.15;
          downBord.children[1].material.opacity = 0.15;
        }
        
        if (a === leftObj.uuid) {
          moveForward = true;
          leftBord.children[0].material.opacity = on;
          leftBord.children[1].material.opacity = on;
        }
        else if(moveForward) {
          moveForward = false;
          leftBord.children[0].material.opacity = 0.15;
          leftBord.children[1].material.opacity = 0.15;
        }
        
        if (a === rightObj.uuid) {
          moveBackward = true;
          rightBord.children[0].material.opacity = on;
          rightBord.children[1].material.opacity = on;
        }
        else if(moveBackward){
          moveBackward = false;
          rightBord.children[0].material.opacity = 0.15;
          rightBord.children[1].material.opacity = 0.15;
        }

        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveLeft) - Number(moveRight);
        
        var obj = usingPhone ? camera: controls.getObject();

        direction.normalize();//.applyQuaternion(obj.quaternion);

        velocity.z += direction.z * 50 * delta;
        velocity.x += direction.x * 50 * delta;

        //if(notInited || moveForward || moveBackward || moveLeft || moveRight) {
          cameraOrtho2.position.x = cameraOrtho2.position.x - velocity.x;
          cameraOrtho2.position.z = cameraOrtho2.position.z - velocity.z;
          cameraOrtho2.updateProjectionMatrix();

          // Set the raycaster position
          raycaster.set(
              cameraOrtho2.position,
              new THREE.Vector3(0, -1, 0)
            );

          var intersects = raycaster.intersectObjects([terrain]);

          if(intersects.length) {            
            obj.position.set(
              obj.position.x - velocity.x,
              2060 - intersects[0].distance,
              obj.position.z - velocity.z
            );

            upObj.position.x = obj.position.x + 54.75;
            upObj.position.y = obj.position.y - 60;
            upObj.position.z = obj.position.z;            

            downObj.position.x = obj.position.x + 54.75;
            downObj.position.y = obj.position.y - 60;
            downObj.position.z = obj.position.z;
            

            leftObj.position.x = obj.position.x + 54.75;
            leftObj.position.y = obj.position.y - 60;
            leftObj.position.z = obj.position.z;

            rightObj.position.x = obj.position.x + 54.75;
            rightObj.position.y = obj.position.y - 60;
            rightObj.position.z = obj.position.z;

            upBord.position.x = obj.position.x + 54.75;
            upBord.position.y = obj.position.y - 60;
            upBord.position.z = obj.position.z;

            downBord.position.x = obj.position.x + 54.75;
            downBord.position.y = obj.position.y - 60;
            downBord.position.z = obj.position.z;

            leftBord.position.x = obj.position.x + 54.75;
            leftBord.position.y = obj.position.y - 60;
            leftBord.position.z = obj.position.z;

            rightBord.position.x = obj.position.x + 54.75;
            rightBord.position.y = obj.position.y - 60;
            rightBord.position.z = obj.position.z;
            
            skyBox.position.x = obj.position.x;
            skyBox.position.y = obj.position.y;
            skyBox.position.z = obj.position.z;
            
            notInited = false;
          }
          else {
            cameraOrtho2.position.x = obj.position.x;
            cameraOrtho2.position.z = obj.position.z;
          }
        //}

        prevTime = time;

        //stats.update();
      }

      function onWindowResize(event) {
        SCREEN_WIDTH = window.innerWidth;
        SCREEN_HEIGHT = window.innerHeight;

        camera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
        camera.updateProjectionMatrix();

        renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
        effect.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
      }

      function onKeyDown(event) {
        switch(event.keyCode) {
          case 78: { /*N*/ 
            lightDir *= -1;
          } break;

          case 77: { /*M*/
            animDeltaDir *= -1;
          } break;

          case 38: // up
          case 87: { // w
            moveForward = true;
          } break;

          case 37: // left
          case 65: { // a
            moveLeft = true;
          } break;

          case 40: // down
          case 83: { // s
            moveBackward = true;
          } break;

          case 39: // right
          case 68: { // d
            moveRight = true;
          } break;
        }
      }

      function onKeyUp(event) {
        switch(event.keyCode) {
          case 38: // up
          case 87: { // w
            moveForward = false;
          } break;

          case 37: // left
          case 65: { // a
            moveLeft = false;
            } break;

          case 40: // down
          case 83: { // s
            moveBackward = false;
          } break;

          case 39: // right
          case 68: { // d
            moveRight = false;
          } break;
        }
      }

      function applyDisplacementMap(mesh, renderer, target, minHeight, maxHeight) {
        var uvs = mesh.geometry.attributes.uv.array;
        var positions = mesh.geometry.attributes.position.array;
        var normals = mesh.geometry.attributes.normal.array;
        var position = new THREE.Vector3();
        var normal = new THREE.Vector3();
        var uv = new THREE.Vector2();

        var width = target.width;
        var height = target.height;

        var buffer = new Uint8Array((4 * (width * height)));
        renderer.readRenderTargetPixels(target, 0, 0, width, height, buffer);

        for(var index = 0; index < positions.length; index+=3) {
          position.fromArray(positions,index);

          normal.fromArray(normals,index);
          uv.fromArray(uvs,(index/1.5)||0);

          var u = Math.min((Math.abs(uv.x)*width),width-1);
          var v = Math.min((Math.abs(uv.y)*height),height-1);

          var pos = (u+v*width) * 3;
          normal.normalize().multiplyScalar(minHeight + (maxHeight - minHeight) * buffer[pos] / 255.0);
          position = position.add(normal);
          position.toArray(positions, index);
        }

        mesh.geometry.needsUpdate = true;
      }
      
      function drawSimpleSkybox() {
        // define path and box sides images
        var path = 'skybox/';
        var sides = [ path + 'sbox_px.jpg', path + 'sbox_nx.jpg', path + 'sbox_py.jpg', path + 'sbox_ny.jpg', path + 'sbox_pz.jpg', path + 'sbox_nz.jpg' ];

        // load images
        scCube = THREE.ImageUtils.loadTextureCube(sides);
        scCube.format = THREE.RGBFormat;

        // prepare skybox material (shader)
        var skyShader = THREE.ShaderLib["cube"];
        
        skyShader.uniforms["tCube"].value = scCube;
        
        var skyMaterial = new THREE.ShaderMaterial( {
            fragmentShader: skyShader.fragmentShader, vertexShader: skyShader.vertexShader,
            uniforms: skyShader.uniforms, depthWrite: false, side: THREE.BackSide
        });

        // create Mesh with cube geometry and add to the scene
        skyBox = new THREE.Mesh(new THREE.BoxGeometry(12000, 12000, 12000), skyMaterial);
        skyMaterial.needsUpdate = true;

        skyBox.UserData = {name:"skyBox"};

        scene.add(skyBox);
    }
    </script>

  </body>
</html>
