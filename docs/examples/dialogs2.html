<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>3D dialog test</title>
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<style>
  body {
    background: #000;
    color: #ccc;
    padding: 0;
    margin: 0;
    overflow: hidden;
    font-family: georgia;
    font-size:1.1em;
  }

  #left_hud {
    pointer-events: none;
    position: absolute;
    z-index: 3;
    left: 0;
    width: 45%;
    height: 100%;
    margin-left: 2.5%;
  }

  #right_hud {
    pointer-events: none;
    position: absolute;
    z-index: 3;
    right: 0;
    width: 45%;
    height: 100%;
    margin-right: 2.5%;
  }

  #guide_circle_left {
    pointer-events: none;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%,-50%);
    width: 2.5vw;
    height: 2.5vw;
    border-radius: 100%;
  }

  .other-ball {
    width: 1px;
    height: 1px;
    border-radius: 50%;
    background: #fff;
    position: absolute;
    z-index: 2;
    transform: translate(-50%, -50%);
    top:50%;
    left:50%;
  }

  #guide_circle_right {
    pointer-events: none;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%,-50%);
    width: 2.5vw;
    height: 2.5vw;
    border-radius: 100%;
  }
</style>
</head>
<body>
<div id="left_hud">
  <div id="guide_circle_left"><div class="other-ball"></div></div>
</div>

<div id="right_hud">
  <div id="guide_circle_right"><div class="other-ball"></div></div>
</div>

<div id="container"></div>
<style>
  #testDialog {
    border-radius: 10px;
    border:3px solid #888;
    background-color:#444;
    color: #fff;
    font-size:14px;
    font-family: Helvetica;
    position:absolute;
    top:0;
    left:0;
    margin:0;
    padding: 0 0.8em;
    transform-origin: top left;
  }

  #testDialog h2 {
    margin: 0.8em 0;
    text-shadow: 0px 1px #222;
  }

  #testDialog p, #testDialog div.section {
    padding: 0;
    margin:0.8em 0;
    vertical-align:middle;
  }

  #testDialog .button {
    display: inline-block;
    zoom: 1; /* zoom and *display = ie7 hack for display:inline-block */
    vertical-align: baseline;
    outline: none;
    cursor: pointer;
    text-align: center;
    text-decoration: none;
    font: 14px/100% Arial, Helvetica, sans-serif;
    padding: .5em 2em .55em;
    margin:0;
    text-shadow: 0 1px 1px rgba(0,0,0,.3);
    -webkit-border-radius: .5em;
    -moz-border-radius: .5em;
    border-radius: .5em;
    -webkit-box-shadow: 0 1px 2px rgba(0,0,0,.2);
    -moz-box-shadow: 0 1px 2px rgba(0,0,0,.2);
    box-shadow: 0 1px 2px rgba(0,0,0,.2);

    color: #d7d7d7;
    border: solid 1px #333;
    background: #333;
    font-weight: bold;
    background: -webkit-gradient(linear, left top, left bottom, from(#666), to(#000));
    background: -moz-linear-gradient(top, #666, #000);
  }

   #testDialog.hover .button {
    background: #000;
    background: -webkit-gradient(linear, left top, left bottom, from(#444), to(#000));
    background: -moz-linear-gradient(top,  #444,  #000);
  }

  #testDialog hr {
    border: none;
    background: #333;
    height: 2px;
    margin: 0.8em 0;
    box-shadow: 1px 1px 1px 1px #555;
  }

  #testDialog .sunk {
    background: #333;
    color: #eee;
    border-radius: 0.6em;
    box-shadow: inset 0px 2px 10px 0px rgba(0, 0, 0, 0.6);
    padding: 0.5em;
    text-shadow: 0px 1px #222;
    margin: 0.8em 0;
    overflow:hidden;
  }

  #testDialog.active .button {
    color: #666;
    background: -webkit-gradient(linear, left top, left bottom, from(#000), to(#444));
    background: -moz-linear-gradient(top,  #000,  #444);
  }
</style>
<div id="testDialog" class="">
  <div class="section"><div class="button">Button 1</div> <div class="button">Button 2</div></div>
  <hr>
  <div class="sunk">Sunken text</div>
  <h2>Some text</h2>
  <p>some other text</p>
</div>
<canvas id="canvas2"></canvas>
<script src="../build/three.js"></script>
<script src="js/Octree.js"></script>
<script src="js/controls/DeviceOrientationControls.js"></script>
<script src="js/controls/PointerLockControls.js"></script>
<script src="js/loaders/SVGLoader.js"></script>
<!-- <script src="js/utils/BufferGeometryUtils.js"></script> -->

<script src="js/renderers/Projector.js"></script>
<script src="js/shaders/NormalMapShader.js"></script>
<script src="js/ShaderTerrain.js"></script>

<script src="js/Detector.js"></script>
<script src="js/postprocessing/EffectComposer.js"></script>
<script src="js/postprocessing/RenderPass.js"></script>
<script src="js/postprocessing/MaskPass.js"></script>
<script src="js/postprocessing/ShaderPass.js"></script>
<script src="js/shaders/CopyShader.js"></script>

<script>
//Edge Blob polyfill https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob
if (!HTMLCanvasElement.prototype.toBlob) {
   Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {
     value: function (callback, type, quality) {
       var canvas = this;
       setTimeout(function() {
         var binStr = atob( canvas.toDataURL(type, quality).split(',')[1] ),
         len = binStr.length,
         arr = new Uint8Array(len);

         for (var i = 0; i < len; i++ ) {
            arr[i] = binStr.charCodeAt(i);
         }

         callback( new Blob( [arr], {type: type || 'image/png'} ) );
       });
     }
  });
}

new (function() {
  'use strict';

  if(!Detector.webgl) {
    Detector.addGetWebGLMessage();
  }

  var
    renderer,
    scene,
    octree,
    camera,
    stereoCamera,
    composer,
    renderPass,
    effect,
    updateDistortionEffect,

    usingPhone = false,
    yawObject,
    controls,

    clock = new THREE.Clock(),
    prevTime = performance.now(),

    firstRender = true,
    notInited = true,
    SCREEN_WIDTH = window.innerWidth,
    SCREEN_HEIGHT = window.innerHeight,

    up = new THREE.Vector3(0, 1, 0),
    down = new THREE.Vector3(0, -1, 0),
    minusZed = new THREE.Vector3(0, 0, -1),
    allZeros = new THREE.Vector3(0, 0, 0),
    halfPi = Math.PI/2,
    minusHalfPi = - halfPi,
    log4 = Math.log(4),

    //stuff to do with the camera offset and rotation
    foobar,
    dangle = 0,
    dangleChange = 0,
    recenterTimeout,
    recenterState = 0,

    raycaster = new THREE.Raycaster(),
    velocity = new THREE.Vector3(),
    direction = new THREE.Vector3(),

    directionalLight,
    pointLight,

    arrowObjs = [],
    selectableObjs = [],
    moveRight = false,
    moveLeft = false,
    moveForward = false,
    moveBackward = false,
    cameraOrtho2,

    walkSpeed = 0.075,

    skyBox = false,

    docEl,

    xxx;

  init();
  animate();

  function init() {
    initBoilerplate();

    scene.fog = new THREE.Fog(0x9fa2ee, 0, 1550);
    scene.add(new THREE.AmbientLight(0x111111));

    directionalLight = new THREE.DirectionalLight(0xffffff, 4);
    directionalLight.position.set(500, 2000, 0);
    scene.add(directionalLight);

    pointLight = new THREE.PointLight(0xff7f00, 2);
    pointLight.position.set(0, 0, 0);
    scene.add(pointLight);

    initVRControls();
    initSimpleSkybox();
    addDialog('<div><p>Hello, World!</p></div>');
  }

  function animate() {
    requestAnimationFrame(animate);

    var time = performance.now();
    var delta = (time - prevTime) / 1000;
    var obj = usingPhone ? camera : controls.getObject();

    if(firstRender) {
      if(true /* everything in the scene has inited */) {
        foobar = ((window.orientation < 1) ? minusHalfPi : halfPi);

        firstRender = false;

        obj.position.set(0, 13.5, 0);
        obj.rotation.y = halfPi/2;
      }
      else {
        prevTime = time;

        return;
      }
    }

    if(obj) {
      if(usingPhone) {
        controls.update();

        var rotation = new THREE.Euler().setFromQuaternion(yawObject.quaternion, 'XYZ');

        camera.rotation.set(rotation.x, rotation.y, rotation.z);
        camera.rotateOnAxis(up.clone().applyQuaternion(yawObject.quaternion.conjugate()), foobar+dangle);
      }

      stereoCamera.update(camera);

      var intersects = getIntersections(selectableObjs);

      var a = intersects.length ? intersects[0].object.parent.name : -1;

      switch(a) {
        case 0:
          moveForward = true;
          moveLeft = moveRight = moveBackward = false;
        break;

        case 1:
          moveBackward = true;
          moveLeft = moveRight = moveForward = false;
        break;

        case 2:
          moveLeft = true;
          moveRight = moveForward = moveBackward = false;
        break;

        case 3:
          moveRight = true;
          moveLeft = moveForward = moveBackward = false;
        break;

        default:
          moveRight =
          moveLeft =
          moveForward =
          moveBackward =
            false;
        break;
      }

      switch(a) {
        case 4:
          dangleChange = Math.min(0.015, dangleChange + 0.0025 * delta);
          dangle += dangleChange;

          if(!usingPhone) {
            obj.rotation.y += dangleChange;
          }
        break;

        case 5:
          dangleChange = Math.min(0.015, dangleChange + 0.0025 * delta);
          dangle -= dangleChange;

          if(!usingPhone) {
            obj.rotation.y -= dangleChange;
          }
        break;

        default:
          dangleChange = 0;
        break;
      }

      if(a == 6) {
        if(recenterState == 0) {
          recenterTimeout = setTimeout(reCenter1, 2000);
          recenterState = 1;
        }
      }
      else {
        if(recenterState == 1) {
          clearTimeout(recenterTimeout);
          recenterState = 0;
        }
      }

      direction.x = Number(moveLeft) - Number(moveRight);
      direction.y = 0;
      direction.z = Number(moveForward) - Number(moveBackward);

      direction.normalize().applyAxisAngle(up, dangle);

      if(a> -1 && a < 4) {
        velocity.z += (direction.z * 0.15 * delta);
        velocity.x += (direction.x * 0.15 * delta);

        velocity.clampLength(0, walkSpeed);
      }
      else {
        velocity.x = 0;
        velocity.z = 0;
      }

      if(notInited || (a > -1 && a < 4)) {
        cameraOrtho2.x -= velocity.x;
        cameraOrtho2.z -= velocity.z;

        if(notInited) {
          octree.update();
        }

        // Set the raycaster position
        raycaster.set(
            cameraOrtho2,
            down
          );

        raycaster.ray.far = 2001;

        var octreeObjects = octree.search(
            raycaster.ray.origin,
            raycaster.ray.far,
            true,
            raycaster.ray.direction
          );

        intersects = raycaster.intersectOctreeObjects(octreeObjects);

        if(intersects.length) {
          obj.position.set(
            obj.position.x - velocity.x,
            2013 - intersects.reduce((accumulator, currentValue) => {
                return accumulator ?
                  Math.max(accumulator, currentValue.distance) :
                  currentValue.distance
              }, null),
            obj.position.z - velocity.z
          );

          notInited = false;
        }

        cameraOrtho2.x = obj.position.x;
        cameraOrtho2.z = obj.position.z;
      }


      for(var i = 0; i < 14; i++) {
        if(arrowObjs[i]) {
          if(i > 6) {
            for(var j = arrowObjs[i].children.length-1; j > -1; j--) {
              arrowObjs[i].children[j].material.opacity = a === i-7 ? .5: 0.15;
            }
          }

          arrowObjs[i].position.x = obj.position.x;
          arrowObjs[i].position.y = obj.position.y - 12;
          arrowObjs[i].position.z = obj.position.z - 10;

          var thoob = new THREE.Vector3(
              arrowObjs[i].position.x,
              arrowObjs[i].position.y,
              arrowObjs[i].position.z + 10
            );

          arrowObjs[i].position.sub(thoob); // remove the offset
          arrowObjs[i].position.applyAxisAngle(up, dangle);
          arrowObjs[i].rotation.z = dangle;
          arrowObjs[i].position.add(thoob); // remove the offset
        }
      }

      skyBox.position.x = obj.position.x;
      skyBox.position.y = obj.position.y;
      skyBox.position.z = obj.position.z;

      renderer.setScissorTest(true);

      renderer.setScissor(0, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT);
      renderer.setViewport(0, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT);
      renderPass.camera = stereoCamera.cameraL; //note: bending rule by setting RenderPass.camera directly without set/get methods
      composer.render();

      renderer.setScissor(SCREEN_WIDTH / 2, 0, SCREEN_WIDTH / 2, SCREEN_WIDTH);
      renderer.setViewport(SCREEN_WIDTH / 2, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT);
      renderPass.camera = stereoCamera.cameraR; //note: bending rule by setting RenderPass.camera directly without set/get methods
      composer.render();

      renderer.setScissorTest(false);
    }

    prevTime = time;
  }

  function initBoilerplate() {
    Array.prototype.forEach.call(document.getElementsByClassName('other-ball'), item => {
      item.style.backgroundColor = '#ffff';
    });

    docEl = window.document.documentElement;
    docEl.addEventListener("click", function() {
      fullscreen(docEl);
    }, false);

    renderer = new THREE.WebGLRenderer({ antialiasing: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
    document.getElementById('container').appendChild(renderer.domElement);

    octree = new THREE.Octree({
      // uncomment below to see the octree (may kill the fps)
      //scene: scene,
      // when undeferred = true, objects are inserted immediately
      // instead of being deferred until next octree.update() call
      // this may decrease performance as it forces a matrix update
      undeferred: false,
      // set the max depth of tree
      depthMax: Infinity,
      // max number of objects before nodes split or merge
      objectsThreshold: 8,
      // percent between 0 and 1 that nodes will overlap each other
      // helps insert objects that lie over more than one node
      overlapPct: 0.15
    });

    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(100, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 1000000);
    scene.add(camera);

    stereoCamera = new THREE.StereoCamera();
    stereoCamera.eyeSep = 0.07;

    composer = new THREE.EffectComposer(renderer);
    renderPass = new THREE.RenderPass(scene, stereoCamera.cameraL);
    composer.addPass(renderPass);

    effect = new THREE.ShaderPass(getDistortionShaderDefinition());
    composer.addPass(effect);
    effect.renderToScreen = true;

    updateDistortionEffect = setupDistortionEffectAndGUI(effect);
    updateDistortionEffect(camera);

    controls = new THREE.PointerLockControls(camera);
    scene.add(controls.getObject());

    window.addEventListener('deviceorientation', setOrientationControls, true);

    onWindowResize();

    window.addEventListener('resize', onWindowResize, false);
    document.addEventListener('mousedown', onMouseDown, false);
    document.addEventListener('mouseup', onMouseUp, false);
  }

  function fullscreen(container) {
    if(container.requestFullscreen) {
      container.requestFullscreen();
    }
    else if(container.msRequestFullscreen) {
      container.msRequestFullscreen();
    }
    else if(container.mozRequestFullScreen) {
      container.mozRequestFullScreen();
    }
    else if(container.webkitRequestFullscreen) {
      container.webkitRequestFullscreen();
    }
  }

  function getDistortionShaderDefinition() {
    return {
      uniforms: {
        "tDiffuse": {
          type: "t",
          value: null
        },
        "strength": {
          type: "f",
          value: 0
        },
        "height": {
          type: "f",
          value: 1
        },
        "aspectRatio": {
          type: "f",
          value: 1
        },
        "cylindricalRatio": {
          type: "f",
          value: 1
        }
      },

      vertexShader: [
        "uniform float strength;",          // s: 0 = perspective, 1 = stereographic
        "uniform float height;",            // h: tan(verticalFOVInRadians / 2)
        "uniform float aspectRatio;",       // a: screenWidth / screenHeight
        "uniform float cylindricalRatio;",  // c: cylindrical distortion ratio. 1 = spherical

        "varying vec3 vUV;",                // output to interpolate over screen
        "varying vec2 vUVDot;",             // output to interpolate over screen

        "void main() {",
          "gl_Position = projectionMatrix * (modelViewMatrix * vec4(position, 1.0));",

          "float scaledHeight = strength * height;",
          "float cylAspectRatio = aspectRatio * cylindricalRatio;",
          "float aspectDiagSq = aspectRatio * aspectRatio + 1.0;",
          "float diagSq = scaledHeight * scaledHeight * aspectDiagSq;",
          "vec2 signedUV = (2.0 * uv + vec2(-1.0, -1.0));",

          "float z = 0.5 * sqrt(diagSq + 1.0) + 0.5;",
          "float ny = (z - 1.0) / (cylAspectRatio * cylAspectRatio + 1.0);",

          "vUVDot = sqrt(ny) * vec2(cylAspectRatio, 1.0) * signedUV;",
          "vUV = vec3(0.5, 0.5, 1.0) * z + vec3(-0.5, -0.5, 0.0);",
          "vUV.xy += uv;",
        "}"
      ].join("\n"),

      fragmentShader: [
        "uniform sampler2D tDiffuse;",      // sampler of rendered scene?s render target
        "varying vec3 vUV;",                // interpolated vertex output data
        "varying vec2 vUVDot;",             // interpolated vertex output data

        "void main() {",
          "vec3 uv = dot(vUVDot, vUVDot) * vec3(-0.5, -0.5, -1.0) + vUV;",
          "gl_FragColor = texture2DProj(tDiffuse, uv);",
        "}"
      ].join("\n")
    };
  }

  function setupDistortionEffectAndGUI(effect) {
    var
      guiParameters = {
        horizontalFOV:    75,
        strength:         0.56,
        cylindricalRatio: 1.7,
      },
      height;

    return camera => {
      height = Math.tan(THREE.Math.degToRad(guiParameters.horizontalFOV) / 2) / camera.aspect;

      camera.fov = Math.atan(height) * 2 * 180 / 3.1415926535;
      camera.updateProjectionMatrix();

      effect.uniforms[ "strength" ].value = guiParameters.strength;
      effect.uniforms[ "height" ].value = height;
      effect.uniforms[ "aspectRatio" ].value = camera.aspect;
      effect.uniforms[ "cylindricalRatio" ].value = guiParameters.cylindricalRatio;
    };
  }

  function setOrientationControls(e) {
    window.removeEventListener('deviceorientation', setOrientationControls, true);

    if(!e.alpha) {
      return;
    }

    usingPhone = true;

    yawObject = new THREE.Object3D();

    controls = new THREE.DeviceOrientationControls(yawObject);
  }

  function onWindowResize(event) {
    SCREEN_WIDTH = window.innerWidth;
    SCREEN_HEIGHT = window.innerHeight;

    camera.aspect = (SCREEN_WIDTH/2) / SCREEN_HEIGHT;

    renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
    composer.setSize(SCREEN_WIDTH*3, SCREEN_HEIGHT*3);

    updateDistortionEffect(stereoCamera.cameraL);
  }

  function onMouseDown() {
    if(!usingPhone) {
      controls.enabled = true; // Turns on camera rotating with mouse
    }
  }

  function onMouseUp() {
    if(!usingPhone) {
      controls.enabled = false; // Turns on camera rotating with mouse
    }
  }

  function initVRControls() {
    cameraOrtho2 = new THREE.Vector3();

    cameraOrtho2.y = 2000;

    var loader = new THREE.SVGLoader();

    [
      'models/svg/up2.svg',
      'models/svg/down2.svg',
      'models/svg/sleft2.svg',
      'models/svg/sright2.svg',
      'models/svg/left2.svg',
      'models/svg/right2.svg',
      'models/svg/recenter2.svg',
      'models/svg/up1.svg',
      'models/svg/down1.svg',
      'models/svg/sleft1.svg',
      'models/svg/sright1.svg',
      'models/svg/left1.svg',
      'models/svg/right1.svg',
      'models/svg/recenter1.svg',
    ].
    forEach((currentValue, index) => {
      loader.load(currentValue, svgCallback.bind(null, index));
    });
  }

  function svgCallback(objectNumber, paths) {
    var group = new THREE.Group();

    group.rotation.x = minusHalfPi;
    group.scale.set(0.1, -0.1, 0.1);

    for(var i = 0; i < paths.length; i++) {
      var path = paths[i];

      var material = new THREE.MeshBasicMaterial({
          color: path.color,
          side: THREE.DoubleSide,
          depthWrite: false,
          depthTest: false,//objectNumber >6,
          transparent: true,
          opacity: objectNumber > 6 ? 0.15 : 0
        });

      var shapes = path.toShapes(true);

      for(var j = 0; j < shapes.length; j++) {
        var shape = shapes[j];

        var geometry = new THREE.ShapeBufferGeometry(shape);
        var mesh = new THREE.Mesh(geometry, material);

        group.add(mesh);
      }
    }

    group.name = objectNumber;

    arrowObjs[objectNumber] = group;

    if(objectNumber < 7) {
      selectableObjs[objectNumber] = group;
    }

    scene.add(group);
  }

  function initSimpleSkybox() {
    // define path and box sides images
    var path = 'skybox/';

    // load images
    var skyCube = THREE.ImageUtils.loadTextureCube([
        path + 'sbox_px.jpg',
        path + 'sbox_nx.jpg',
        path + 'sbox_py.jpg',
        path + 'sbox_ny.jpg',
        path + 'sbox_pz.jpg',
        path + 'sbox_nz.jpg'
      ]);
    skyCube.format = THREE.RGBFormat;

    // prepare skybox material (shader)
    var skyShader = THREE.ShaderLib["cube"];

    skyShader.uniforms["tCube"].value = skyCube;

    var skyMaterial = new THREE.ShaderMaterial( {
        fragmentShader: skyShader.fragmentShader,
        vertexShader: skyShader.vertexShader,
        uniforms: skyShader.uniforms,
        depthWrite: false,
        side: THREE.BackSide
      });

    // create Mesh with cube geometry and add to the scene
    skyBox = new THREE.Mesh(new THREE.BoxGeometry(12000, 12000, 12000), skyMaterial);
    skyMaterial.needsUpdate = true;

    skyBox.UserData = {
        name:"skyBox"
      };

    scene.add(skyBox);
  }

  function reCenter1() {
    recenterState = 2;

    Array.prototype.forEach.call(document.getElementsByClassName('other-ball'), item => {
      item.style.backgroundColor = '#000000';
    });

    recenterTimeout = setTimeout(reCenter2, 4000);
  }

  function reCenter2() {
    if(!usingPhone) {
      dangle = controls.getObject().rotation.y;
    }
    else {
      var rotation = foobar + dangle;
      var rotation2 = minusZed
          .clone()
          .applyQuaternion(yawObject.quaternion.conjugate())
          .applyAxisAngle(up, rotation);

      rotation2.y = 0;

      dangle = minusZed.angleTo(rotation2);

      if (camera.rotation.y < 0) {
        dangle *= -1;
      }

      foobar = rotation-dangle;
    }

    Array.prototype.forEach.call(document.getElementsByClassName('other-ball'), item => {
      item.style.backgroundColor = '#ffffff';
    });

    recenterState = 0;
  }

  function getIntersections(objects) {
    var vector = minusZed.clone();

    if(usingPhone) {
      vector
        .applyQuaternion(camera.quaternion)

      raycaster.set(camera.position, vector);
    }
    else {
      vector
        .applyQuaternion(controls.getObject().children[0].quaternion)
        .applyQuaternion(controls.getObject().quaternion)

      raycaster.set(controls.getObject().position, vector);
    }

    return raycaster.intersectObjects(objects, true);
  }

  function hasClass(el, className) {
    return el.classList ?
      el.classList.contains(className):
      new RegExp('(^| )' + className + '( |$)', 'gi').test(el.className);
  }

  function getRandomColor() {
    var letters = '0123456789ABCDEF';
    var color = '#';

    for (var i = 0; i < 6; i++) {
      color += letters[Math.floor(Math.random() * 16)];
    }

    return color;
  }
  
  function stringifyElementWithCss(elem) {
    elem.style = getStylesWithoutDefaults(elem)+"transform: scale(4); transform-origin: top left;";

    var elements = document.querySelectorAll('#testDialog *');
    Array.prototype.forEach.call(elements, function(el, i){
      el.style = getStylesWithoutDefaults(el);
    });

    var oSerializer = new XMLSerializer();
    var retval = oSerializer.serializeToString(elem);
    
    Array.prototype.forEach.call(elements, function(el, i){
      el.removeAttribute("style");
    });
    
    elem.removeAttribute("style");

    return retval;
  }
  
  function getStylesWithoutDefaults( element ) {

  // creating an empty dummy object to compare with
  var dummy = document.createElement( 'element-' + ( new Date().getTime() ) );
  document.body.appendChild( dummy );

  // getting computed styles for both elements
  var defaultStyles = getComputedStyle( dummy );
  var elementStyles = getComputedStyle( element );

  // calculating the difference
  var diff = "";
  for( var key in elementStyles ) {
    if(
      elementStyles.hasOwnProperty(key) &&
      defaultStyles[key] != elementStyles[key]
    ) {
      diff += (key.replace(/[A-Z]/, function(match) { return "-"+match.toLowerCase() }))+':'+elementStyles[ key ]+';';
    }
  }

  // clear dom
  dummy.remove();
  
  return diff;
}
  
  function findFirstMatch(rects, x, y) {
    for(var i = rects.length -1; i > -1; i--) {
      var a = rects[i];
      
      if(!(
        y < a.top ||
        y > a.bottom ||
        x > a.right ||
        x < a.left
      )) {
        return a;
      }    
    }
    
    return null;
  }

  function addDialog(markup) {
    var elem = document.getElementById('testDialog');
    elem = elem.getBoundingClientRect();

    var width = elem.width;
    var height = elem.height;

    elem = document.querySelectorAll('#testDialog .button');

    elem.forEach(function(item) {
      var a = item.getBoundingClientRect();
      item.style = "position:relative;left:-"+(a.x+(a.width/2))+"px;top:-"+(a.y + (a.height/2))+"px;";
    });

    for(var i = elem.length - 1, elem = []; i > -1; i--) {
      var b = document.elementFromPoint(0, 0);
      var c = b;

      while(!hasClass(c, 'button') && c.parentNode) {
        c = c.parentNode;
      }

      if(!c.parentNode) {
        continue;
      }

      c.style.pointerEvents = "none";
      elem.unshift(c);
    }

    /*
    var c = document.getElementById("canvas2");
    c.setAttribute("width", Math.ceil(width));
    c.setAttribute("height", Math.ceil(height));
    c.style="position:absolute;top:0;right:0";
    var ctx = c.getContext("2d");

    ctx.fillStyle= '#FFFFFF';
    ctx.fillRect(0, 0, width, height);
    */
    elem.forEach((item, index, arr) => {
      item.removeAttribute("style");

      //ctx.fillStyle = getRandomColor();
      var a = item.getBoundingClientRect();
      
      a = {
        top: Math.round(a.top),
        left: Math.round(a.left),
        bottom: Math.round(a.bottom),
        right: Math.round(a.right),
        zOrder: index
      }

      /*ctx.fillRect(
        a.left,
        a.top,
        a.right - a.left,
        a.bottom - a.top
      );*/
      
      arr[index] = a;
    });

    console.log(findFirstMatch(elem, 16, 16));

  var canvas = document.getElementById('canvas2');
  canvas.setAttribute("width", Math.ceil(width)*4);
  canvas.setAttribute("height", Math.ceil(height)*4);
  canvas.style="position:absolute;top:0;right:0;opacity:0;pointer-events:none";
  var ctx = canvas.getContext("2d");
  //ctx.fillStyle= '#FFFFFF88';
  //ctx.fillRect(0, 0, Math.ceil(width)*4, Math.ceil(height)*4);


  var data = '<svg xmlns="http://www.w3.org/2000/svg" width="'+(Math.ceil(width)*4)+'" height="'+(Math.ceil(height)*4)+'">' +
             '<foreignObject width="100%" height="100%">' +
             stringifyElementWithCss(document.getElementById('testDialog')) +
             
             '</foreignObject>' +
             '</svg>';
             
  console.log(data);

  document.getElementById('testDialog').style.display = 'none';
      
  data = encodeURIComponent(data);
  
  var img = new Image();

  img.onload = function() {
    ctx.drawImage(img, 0, 0);
    
    var quad_vertices = [
      0,  0, 0,
      0,  height/120, 0,
      width/120, height/120, 0,
      width/120, 0, 0
    ];

    var quad_uvs = [
      0, 0,
      0, 1,
      1, 1,
      1, 0,
    ];

    var quad_indices = [
      0, 2, 1, 0, 3, 2
    ];
    
    var geometry = new THREE.BufferGeometry();

    var vertices = new Float32Array(quad_vertices);
    // Each vertex has one uv coordinate for texture mapping
    var uvs = new Float32Array(quad_uvs);
    // Use the four vertices to draw the two triangles that make up the square.
    var indices = new Uint32Array(quad_indices);

    // itemSize = 3 because there are 3 values (components) per vertex
    geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
    geometry.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));
    geometry.setIndex(new THREE.BufferAttribute(indices, 1));
    
    var material = new THREE.MeshBasicMaterial({
      side: THREE.DoubleSide,
      transparent: true
    });
    
    material.map = new THREE.CanvasTexture(canvas);
    
    // it's necessary to apply these settings in order to correctly display the texture on a shape geometry
    //texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    //texture.repeat.set(1, 1);

    var mesh = new THREE.Mesh(
        geometry,
        material
      );
    mesh.position.set(-5.5, 13, -5);
    mesh.rotation.set(0, 82, 0);
    mesh.scale.set(1, 1, 1);
    scene.add(mesh);
    
    /*canvas.toBlob(function(blob) {
       var newImg = document.createElement('img'),
       url = URL.createObjectURL(blob);

       newImg.onload = function() {
       // no longer need to read the blob so it's revoked
       URL.revokeObjectURL(url);
     };

     newImg.src = url;
     document.body.appendChild(newImg);
     
     */
   };

  img.src = "data:image/svg+xml," + data;

  }

})();
</script>
</body>
</html>
